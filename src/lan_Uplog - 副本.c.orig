#include <stdio.h>
#include <time.h>
#include <malloc.h>
#include <unistd.h>
#include <pthread.h>
#include "string.h"
#include "utoall.h"
#include "utomon.h"
#include "ncdef.h"
#include "nwdef.h"
#include "pasdb.h"
#include "lan_md5.h"
#include <stdlib.h>
#include <errno.h>



int8 pasGetLongTimeId();


#include <sys/stat.h>
#include <sys/types.h>

#define    PACKAGE_MAXLEN    50000
#define    JPG_MAXLEN         1024*1024

#define   LOG_DIR                "/home/ncmysql/nw/log/"
#define  SCREENJPG_DIR      "/home/ncmysql/nw/screenJPG/"  //屏幕JPG图片存放根目录
#define    SCREENALTERJPG_DIR "/home/ncmysql/nw/screenAlterJPG/"    //告警JPG图片存放根目录
#define    PROCESSJPG_DIR     "/home/ncmysql/nw/processJPG/"	    //进程JPG图片存放根目录
#define    MYTEMP_DIR         "/home/ncmysql/nw/temp/"               //临时目录
#define    MYLOG_FILE         "/home/ncmysql/nw/temp/log.dat"       //系统日志存放目录
#define    CONF_FILE           "/home/ncmysql/nw/conf/debug.conf"   //配置文件存放目录

char  ConfIP[512];


int    timeToString(unsigned int now, char *year, char *mon, char *day)
{

	if( (year == NULL)||(mon==NULL)||(day==NULL) || (now == 0)){
		return -1;
	}

	struct tm *time1;
	time1 = localtime(&now);
		
	//当前年份
	snprintf(year, 5, "%d", time1->tm_year+1900);

	//当前月份
	if( (time1->tm_mon+1 > 0) && (time1->tm_mon+1 <= 9) )
		snprintf(mon, 3, "0%d", time1->tm_mon+1);
	else
		snprintf(mon, 3, "%d", time1->tm_mon+1 );

	//当前日
	if( (time1->tm_mday > 0) && (time1->tm_mday <= 9) )
		snprintf(day,  3, "0%d", time1->tm_mday);
	else
		snprintf(day,  3, "%d ", time1->tm_mday);

	return 0;
}




int  recodeLogInfo(char * str1, char * str2, char * str3)
{
	int    iRet = -1;
	int   iReturn = 0;
	char  destDir[1024];
	memset(destDir, 0, sizeof(destDir));
	snprintf(destDir, sizeof(destDir)-1,  "%s", MYTEMP_DIR);
	iReturn = mkdir(destDir, S_IRWXU);

	//system("mkdir -p /home/ncmysql/nw/temp/");


	FILE * fp = fopen(MYLOG_FILE, "a+");
	if(!fp){
		iRet = -1;
	}else{

		char  year[10];
		char  mon[10];
		char  day[10];
		char  hour[10];
		char  min[10];
		char  sec[10];

		time_t  now;
		struct tm *time1;
		time(&now);
		time1 = localtime(&now);
		
		//当前年份
		snprintf(year, 5, "%d", time1->tm_year+1900);

		//当前月份
		if( (time1->tm_mon+1 > 0) && (time1->tm_mon+1 <= 9) )
			snprintf(mon, 3, "0%d", time1->tm_mon+1);
		else
			snprintf(mon, 3, "%d", time1->tm_mon+1);


		//当前日
		if( (time1->tm_mday > 0) && (time1->tm_mday <= 9) )
			snprintf(day,  3, "0%d", time1->tm_mday);
		else
			snprintf(day,  3, "%d", time1->tm_mday);
		//当前时
		snprintf(hour, 3, "%02d", time1->tm_hour);

		//当前分
		snprintf(min, 3, "%02d", time1->tm_min);

		//当前秒
		snprintf(sec, 3, "%02d", time1->tm_sec);

		int pid = getpid();
		int  parentpid = getppid();
		fprintf(fp,"%s-%s-%s %s:%s:%s parentpid:%d pid:%d  ",year,mon,day,hour,min,sec,parentpid , pid);
			
		char  msg[512];
		memset(msg,0,sizeof(msg));
		
		if(str1){
			//snprintf(msg,sizeof(msg)-1,"%s",str1);
			fprintf(fp,"%s",str1);
		}
		if(str2){
			//snprintf(msg,sizeof(msg)-1,"%s",str2);
			fprintf(fp,"%s",str2);
		}
		if(str3){
			//snprintf(msg,sizeof(msg)-1,"%s",str3);
			fprintf(fp,"%s",str3);
		}
	
		fprintf(fp,"\r\n");
		fclose(fp);
	}

	return iRet;
}

int   CheckIP(int  iFd)
{
	int        iRet = 0;
	unsigned int nIP = 0;
	unsigned int nPort = 0;
	char * currentIP = NULL;

	utComGetSockIp(iFd, &nIP, &nPort);
	currentIP =  utComHostIp(nIP);
	
	if(!currentIP){
		recodeLogInfo("ip == NULL", "", "");
	}else{
		if(strlen(ConfIP) == 0){

			iRet = 1;
		}else if(!strcmp(currentIP, ConfIP)){
			recodeLogInfo("检测到：", ConfIP, "  发送的数据");

			iRet = 1;
		}
	}

	return iRet;
}


///////////////////////////////////////////////////////////
//Funtion: 创建当天日志目录
//参数：  
//      dir   : 创建的目录路径
//      dirlen: dir 的空间大小(至少为200)
//返回值：
//       0: 成功
//      -1: 参数有误
//      -2: 操作失败
//////////////////////////////////////////////////////////
int  createDir(char *dir,  int dirlen)
{
	int iRet = 0;
	if( (dir == NULL) || (dirlen < 200) ){
		iRet = -1;
	}
	///////////////查询当前文件应该存放的路径/////////
	char  year[10];
	char  mon[10];
	char  day[10];

	time_t  now;
	struct tm *time1;
	time(&now);
	time1 = localtime(&now);
		
	//当前年份
	snprintf(year, 5, "%d", time1->tm_year+1900);

	//当前月份
	if( (time1->tm_mon+1 > 0) && (time1->tm_mon+1 <= 9) )
		snprintf(mon, 3, "0%d", time1->tm_mon+1);
	else
		snprintf(mon, 3, "%d", time1->tm_mon+1 );

	//当前日
	if( (time1->tm_mday > 0) && (time1->tm_mday <= 9) )
		snprintf(day,  3, "0%d", time1->tm_mday);
	else
		snprintf(day,  3, "%d", time1->tm_mday);
		
	//当前文件所在路径
	snprintf(dir, dirlen, "%s%s%s%s",LOG_DIR, year,  mon,  day);

	///////////////创建目录/////////////////////////
	iRet = mkdir(dir, S_IRWXU| S_IRWXG |S_IRWXO);
	return iRet;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Funtion：查询当前数据应该保存在哪个文件中
//参数：  
//      Userid :  要查询的客户端的ID??
//      filetype:   要查询的日志文件类型
//      filePath:  ?鼻拔募存放的路?
//      savefile:  最终查到的保存数据的文件名
//      savefilelen:  savefile ?侄?目占涑ざ龋ㄖ辽傥?00）
//返?刂担?
//       0: 查询成功
//      -1: 参数错误
////////////////////////////////////////////////////////////////
int    searchPos2(int Userid,  char *filetype, char *filePath, char *savefile,  int savefilelen)
{	

	int iRet = -1;
	if((filetype == NULL) || (filePath == NULL) || (savefile == NULL) || (savefilelen < 300))
	{
		iRet = -1;
	}
	else
	{
		char    tableName[512];
		char    DefaultPath[512];
		char    comm[512];
		char  	year[10];
		char  	mon[10];
		char	day[10];

		memset(DefaultPath, 0, sizeof(DefaultPath));
		memset(tableName, 0, sizeof(tableName));
		memset(comm, 0, sizeof(comm));
		memset(year, 0, sizeof(year));
		memset(mon, 0, sizeof(mon));
		memset(day, 0, sizeof(day));


		time_t  now = 0;
		struct tm *time1 = NULL;
		time(&now);
		time1 = localtime(&now);
		
		//当前年份
		snprintf(year, 5, "%d", time1->tm_year+1900);

		//当前月份
		if( (time1->tm_mon+1 > 0) && (time1->tm_mon+1 <= 9) )
			snprintf(mon, 3, "0%d", time1->tm_mon+1);
		else
			snprintf(mon, 3, "%d", time1->tm_mon+1 );

		//当前日
		if( (time1->tm_mday > 0) && (time1->tm_mday <= 9) )
			snprintf(day,  3, "0%d", time1->tm_mday);
		else
			snprintf(day,  3, "%d", time1->tm_mday);

		
		//当前信息存放的数据库表名
		snprintf(tableName, sizeof(tableName)-1, "%s_%s%s", filetype, year,  mon);

		//默认的路径
		snprintf(savefile, savefilelen, "%s/%s_%s999999.dat",filePath, tableName,day);
		
		FILE *fp = fopen(savefile,  "a+");
		if(fp){
			fseek(fp, 0L, SEEK_END); 	//定位到文件末尾
			long Filelen = ftell(fp);    //获取文件大小
			fclose(fp);
			if(Filelen < 10*1024*1024){
				return 0;
			}
			

			int num1, num2,num3,num4,num5,num6;
			for(num1 = 0; num1 <= 9;  num1 ++)
				for(num2 = 0; num2 <= 9; num2++)
					for(num3=0; num3<=9; num3++)
						for(num4=0; num4<=9; num4++)
							for(num5=0; num5<=9; num5++)
								for(num6=0; num6<=9; num6++)
								{
									snprintf(DefaultPath, sizeof(DefaultPath)-1, "%s/%s_%s%d%d%d%d%d%d.dat",filePath, tableName,day, num1,num2,num3,num4,num5,num6);
									FILE *file = fopen(DefaultPath, "r");
									if(file){
										fclose(file);
									}else{
										snprintf(comm, sizeof(comm)-1, "mv %s %s", savefile, DefaultPath);
										system(comm);
										return 0;
									}
								}
			
		}
	}
	return 0;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Funtion：查询当前数据应该保存在哪?鑫募?
//参数：  
//      Userid :  要查询的客户端的ID号
//      filetype:   要查询的日志文件类型
//      filePath:  当前文件存放的路径
//      savefile:  最终查到的保?媸据的文件?
//      savefilelen:  savefile 字段?目?间长度（至少?00）
//返?刂担?
//       0: 查询成功
//      -1: 参数错误
////////////////////////////////////////////////////////////////
int    searchPos(int Userid,  char *filetype, char *filePath, char *savefile,  int savefilelen)
{	
	int iRet = -1;
	if((filetype == NULL) || (filePath == NULL) || (savefile == NULL) || (savefilelen < 300))
	{
		iRet = -1;
	}
	else
	{
		int first,  second,  third;
		for(first = 0; first <= 9; first++)
		    for(second = 0; second <= 9 ; second++)
		        for(third = 0;  third <= 9;  third++)
			{
				snprintf(savefile, savefilelen, "%s/%d_%s_%d%d%d.log",filePath, Userid ,filetype,  first, second, third);
	
				FILE *fp = fopen(savefile, "r");
				if(fp == NULL)
				{
					if( (first ==0) && (second == 0)  && (third == 0) )
					{
						return 0;
				       	}
					else
					{
						int number = first*100 + second*10 + third - 1;
						if(number < 0)
							return -1;
						else if( (number >= 0) && (number <= 9) )
						{
							snprintf(savefile, savefilelen, "%s/%d_%s_00%d.log",filePath, Userid ,filetype,  number);
						}
						else if( (number >= 10) && (number <= 99))
						{
							snprintf(savefile, savefilelen, "%s/%d_%s_0%d.log", filePath, Userid ,filetype,  number);
						}
						else 
						{
							snprintf(savefile, savefilelen, "%s/%d_%s_%d.log", filePath, Userid ,filetype,  number);
						}

						if( (fp = fopen(savefile, "r")) != NULL)
						{
							fseek(fp, 0L, SEEK_END); //定位到文件末尾
							long Filelen = ftell(fp);    //获取文件大小
							if(Filelen < 100*1024*1024)
								return 0;
							else
							{
								number += 1;
								if(number < 0)
									return -1;
								else if( (number >= 0) && (number <= 9) )
								{
									snprintf(savefile, savefilelen, "%s/%d_%s_00%d.log", filePath, Userid ,filetype,  number);
								}
								else if( (number >= 10) && (number <= 99))
								{
									snprintf(savefile, savefilelen, "%s/%d_%s_0%d.log", filePath, Userid ,filetype,  number);
								}
								else 
								{
									snprintf(savefile, savefilelen, "%s/%d_%s_%d.log", filePath, Userid ,filetype,  number);
								}
								if(fp = fopen(savefile, "w"))
								{	
									fclose(fp);
									return 0;
								}
								else
									return -1;
							}
						}
					}
				}
				else
				{
					fclose(fp);
					fp = NULL;
				}
			}//end for()
	}
	return iRet;
}

//从Webaddr中提取host字段
int	GetHost(char *Webaddr, char * Host, int  len)
{
	if((Webaddr == NULL) || (Host == NULL) || (len <= 0)){
		return -1;
	}
	
	char    buffer[512];
	memset(buffer, 0, sizeof(buffer));
	char * pos1 = strstr(Webaddr, "//");
	char * pos2 = strstr(pos1+2, "/");
	if(pos1 && pos2 && (pos2 -pos1 > 0)){
		strncpy(buffer, pos1+2, pos2-pos1-2);
		if( 0 == strncmp(buffer, "www.", 4)){
			snprintf(Host, len, "%s",  buffer+4);
		}else{
			snprintf(Host, len, "%s",  buffer);
		}
	}
	return 0;
}



//1、文件操作日志上传
int  Lan_FileLog_Up(utShmHead *psShmHead, int iFd,utMsgHead *psMsgHead)
{	
	int   Nums   = 0;
	unsigned int   compid = 0;
	unsigned int   userid = 0;
	char  mac[20];
	unsigned int   groupid = 0;
	unsigned int   groupid2 = 0;
	char  devname[32];
	char  username[25];
	unsigned int   sip  = 0;
	char  procname[73];
	int   Mark = 0;
	char  Indexid[25];
	unsigned int   Stime = 0;
	char  souPath[300];
	char  destPath[300];
	char  Content[30];

	char  Status = 0;
	int   Nums2  = 0;
	long  iReturn= 0;
	FILE   *fp = NULL;
	char      *data = NULL;

	char dir[512]; //保存目录
	char savefile[512];  //保存的文件名	
	//utMsgPrintMsg(psMsgHead);

	recodeLogInfo(" 接收文件日志1：" , "", "");

	memset(mac, 0, sizeof(mac));
	memset(devname, 0, sizeof(devname));
	memset(username, 0, sizeof(username));
	memset(procname,  0, sizeof(procname));
	memset(Indexid,   0, sizeof(Indexid));
	memset(souPath, 0, sizeof(souPath));
	memset(destPath,   0, sizeof(destPath));
	memset(Content, 0, sizeof(Content));
	memset(dir,  0, sizeof(dir));
	memset(savefile, 0, sizeof(savefile));

    	iReturn = utMsgGetSomeNVar(psMsgHead,3,
		                       "compid",   UT_TYPE_ULONG, 4, &compid,
					"userid",  UT_TYPE_ULONG,  4, &userid,
					"Nums",    UT_TYPE_LONG,  4, &Nums	
					);

	char  string[2048];
	snprintf(string, sizeof(string)-1, "compid=%u, userid=%d, Nums=%d", compid, userid, Nums);
	recodeLogInfo(" 接收文件日志2：" , string, "");

	if( CheckIP(iFd) != 1){
		Status = 1;
		Nums2 = Nums;

		pasTcpResponse(iFd,psMsgHead,NULL, 3,
					 "compid",   UT_TYPE_LONG,   compid,
					 "Status",   UT_TYPE_STRUCT,  &Status, 1,
					 "Nums",     UT_TYPE_LONG,     Nums2);

		recodeLogInfo("文件日志：" , "过滤该信息！", "");
		return 0;			
	}

	if( (compid == 0) ){
		Status = -1;
		Nums2 = 0;

		pasTcpResponse(iFd,psMsgHead,NULL, /* 密钥，暂时不用  */ 3,
					 "compid",   UT_TYPE_LONG,   compid,
					 "Status",   UT_TYPE_STRUCT,  &Status, 1,
					 "Nums",     UT_TYPE_LONG,     Nums2);

		recodeLogInfo("文件日志：" , "compid为0", "");
		return -1;
	}
	
	//动态开辟存储空间
	data = (char *)malloc(PACKAGE_MAXLEN);
	if(!data){
		Status = -2;
		Nums2 = 0;

		pasTcpResponse(iFd,psMsgHead,NULL, /* 密钥，暂时不用  */ 3,
					 "compid",   UT_TYPE_LONG,   compid,
					 "Status",   UT_TYPE_STRUCT,  &Status, 1,
					 "Nums",     UT_TYPE_LONG,     Nums2);

		recodeLogInfo("文件日志：" , "动态开辟空间失败！", "");

		return -1;
	}else{
		memset(data, 0, PACKAGE_MAXLEN);
	}
	
	
	int    Numbers = 0;
	char  str[12][51];
	memset(str, 0, 12*50);
	//查询当前客户端信息
	nwCompInfo *psComp = (nwCompInfo *)utShmHashLook(psShmHead,NC_LNK_COMPUTE,&compid);
	
	char sql[256];
	memset(sql, 0, sizeof(sql));
	
	sprintf(sql,"select groupid from nwgroup where compid=%lu",compid);
	
	pasDbOneRecord(sql,0,UT_TYPE_ULONG,sizeof(groupid2),&groupid2);	

	//提取信息
	for(Numbers = 0; Numbers < Nums; Numbers++)
	{
		snprintf(str[0], 50, "mac%d", Numbers);
		snprintf(str[1], 50, "groupid%d", Numbers);		
		snprintf(str[2], 50, "devname%d", Numbers);
		snprintf(str[3], 50, "username%d", Numbers);
		snprintf(str[4], 50, "sip%d", Numbers);
		snprintf(str[5], 50, "procname%d", Numbers);
		snprintf(str[6], 50, "Mark%d", Numbers);
		snprintf(str[7], 50, "Indexid%d", Numbers);
		snprintf(str[8], 50, "Stime%d", Numbers);
		snprintf(str[9], 50, "souPath%d", Numbers);
		snprintf(str[10], 50, "destPath%d", Numbers);
		snprintf(str[11], 50, "Content%d", Numbers);

		iReturn = utMsgGetSomeNVar(psMsgHead,12,
					   	str[0],  UT_TYPE_STRING,sizeof(mac)-1, mac,
						str[1],  UT_TYPE_LONG,   4,  &groupid,
						str[2], UT_TYPE_STRING,  sizeof(devname)-1,  devname,
						str[3], UT_TYPE_STRING, sizeof(username)-1,username,
						str[4], UT_TYPE_LONG,   4,  &sip,
						str[5], UT_TYPE_STRING, sizeof(procname)-1, procname,
						str[6], UT_TYPE_LONG,   4,  &Mark,
						str[7], UT_TYPE_STRING, sizeof(Indexid)-1, Indexid,
						str[8], UT_TYPE_LONG,   4,  &Stime,
						str[9], UT_TYPE_STRING, sizeof(souPath)-1, souPath,
						str[10], UT_TYPE_STRING, sizeof(destPath)-1,destPath,
						str[11], UT_TYPE_STRING, sizeof(Content)-1,Content   
					    	);
		if( (strlen(mac)<=0 ) &&
		(groupid == 0)&&
		(strlen(devname) <=0) &&
		(strlen(username)<=0)&&
		(sip==0)&&
		(strlen(procname)<=0) &&
		(Mark == 0)&&
		(strlen(Indexid))&&
		(Stime == 0)&&
		(strlen(souPath) <=0)&&
		(strlen(destPath)<=0) &&
		(strlen(Content)<=0)){
			recodeLogInfo("收到一条空文件日志","", "");
			continue;
			Nums2++;					
		}


		char mystring[512];
		memset(mystring, 0, sizeof(mystring));
		snprintf(mystring, sizeof(mystring)-1, " compid=%u, stime=%u", compid, Stime);
	
		if(sip == 0){
			recodeLogInfo(" 收到一条文件日志:",mystring, "sip == 0");
		}
		if(Stime == 0){
			recodeLogInfo(" 收到一条文件日志:",mystring,  "Stime == 0");
		}
		if(strlen(Indexid) <= 0 ){
			recodeLogInfo(" 收到一条文件日志:", mystring, "Indexid == NULL");
		}
		if( strlen(souPath) <= 0){
			recodeLogInfo(" 收到一条文件日志:", mystring, "souPath == NULL");
		}


		//保存数据到文件中
		unsigned long long currentTime = pasGetLongTimeId(); //获取时间
		if(psComp != NULL){
			userid = psComp->userid;
			groupid= psComp->groupid;
		}	

		groupid = groupid2;
							
		int i ;
		for(i = 0; i < strlen(souPath);   i++){
			if(souPath[i] == '\\')
				souPath[i]  = '/';
		}
			
		for(i = 0; i < strlen(destPath);   i++){
			if(destPath[i] == '\\')
				destPath[i]  = '/';
		}

		snprintf(data+strlen(data),PACKAGE_MAXLEN-strlen(data)-1,  "%llu\t%u\t%u\t%s\t"
					"%u\t%s\t%s\t%u\t"
					"%s\t%d\t%s\t%u\t"
					"%s\t%s\t%s\n",
					currentTime, compid,    userid,       mac,
					groupid,       devname,  username,  sip,
					procname,   Mark,        Indexid,     Stime,
					souPath,     destPath,   Content\
					);
		Nums2++;	
	}//end for()

	//监测记录的Nums2的值是否和Nums相等
	char  mesg[512];
	memset(mesg, 0, sizeof(mesg));
	snprintf(mesg, sizeof(mesg)-1, "compid=%u, userid=%d, Nums=%d, success=%d", compid, userid, Nums, Nums2);
	if(Nums != Nums2){
		Status= -3;
		Nums2 = 0;
		recodeLogInfo("文件日志：Error(Nums != success):", mesg,"");

	}else{
		//创建当天日志目录,并将创建?哪柯即娣诺dir中，以便后面使用该目录
		createDir(dir,  sizeof(dir));

		//查询当前数据应该保存在哪个文件中， 如果查询成功，则打开此文件,失败则返回错误
		if(searchPos2(userid, "nwfilelog",dir, savefile, sizeof(dir))) {
			Status = -4;
			Nums2 = 0;
			recodeLogInfo("文件日志：Error:", "查找存储文件失败！","");
		}else{      

			if( (fp = fopen(savefile, "ab")) == NULL) { //打开存储文件失败
				Status  = -6;
				Nums2 = 0;
				
				time_t now;
				time(&now);
				char sql[2048];
				memset(sql, 0, sizeof(sql));
				snprintf(sql, sizeof(sql)-1,  "insert into nwLogDebug(   compid,stime, type, error, Info) values(%u,%u, \'%s\',%d,\'%s\')", compid,now, "文件日志",errno,savefile);
				iReturn = pasDbExecSql(sql,0);
				printf("插入数据库一条信息................iReturn=%d\n",  iReturn);


				recodeLogInfo("文件日志：Error:", "打开存储文件失败！",savefile);
			}else{	//打开文件成功，则保存数据到文件中
				//给文件加锁
				pasFileSetFileLock(fp);

				fwrite(data, 1,strlen(data) ,  fp);

				//给文件解锁
				pasFileSetFileUnLock(fp);

				fclose(fp);
				fp = NULL;

				Status = 1;

			}
		}		
		recodeLogInfo(" 接收文件日志3：" , mesg, "");		
	}

	pasTcpResponse(iFd,psMsgHead,NULL, /* 密钥，暂时不用  */ 3,
					 "compid",   UT_TYPE_LONG,    compid,
					 "Status",   UT_TYPE_STRUCT,  &Status, 1,
					 "Nums",     UT_TYPE_LONG,    Nums2);
	//printf("------------------------------------receive file log, compid = %u, Status = %d,Num=%d, Nums2 = %d\n", compid, Status,  Nums, Nums2);

	free(data);
	return 0;
}

//2、进程日志上传
int  Lan_PorcessLog_Up(utShmHead *psShmHead, int iFd,utMsgHead *psMsgHead)
{
	int   Nums   = 0;
	unsigned int   compid = 0;
	unsigned int   userid = 0;
	char  mac[20];
	unsigned int   groupid = 0;
	unsigned int	groupid2 = 0;
	char  devname[32];
	char  username[32];
	unsigned int   sip  = 0;
	char  procname[73];
	 int    screenid = 0;

	char  Mark = 0;
	int   Pid  = 0;
	char  Indexid[25];
	char  Pindexid[25];
	unsigned int   Stime = 0;
	unsigned int   Btime = 0;
	int	            nettime = 0;
	int	            wndtime = 0;
	char  Path[257];
	unsigned int      mem = 0 ;
	unsigned int      cpu = 0;
	int      flags = 0;

	char  Status = '\0';
	int   Nums2 = 0;
	long  iReturn= 0;
	FILE   *fp = NULL;
	char    *  data = NULL;

	char dir[300]; //存放目录
	char savefile[300];  //保存的文件名

	//utMsgPrintMsg(psMsgHead);
	recodeLogInfo(" 接收进程日志1：" , "", "");

	memset(mac, 0, sizeof(mac));
	memset(devname, 0, sizeof(devname));
	memset(username, 0, sizeof(username));
	memset(procname,  0, sizeof(procname));
	memset(Indexid, 0, sizeof(Indexid));
	memset(Pindexid, 0, sizeof(Pindexid));
	memset(Path, 0, sizeof(Path));
	memset(dir,  0, sizeof(dir));
	memset(savefile, 0, sizeof(savefile));

    	iReturn = utMsgGetSomeNVar(psMsgHead,3,
		                        "compid",  UT_TYPE_ULONG, 4, &compid,
					"userid",  UT_TYPE_ULONG, 4, &userid,
					"Nums",    UT_TYPE_LONG, 4, &Nums
					);

	char  string[2048];
	snprintf(string, sizeof(string)-1, "compid=%u, userid=%d, Nums=%d", compid, userid, Nums);
	recodeLogInfo(" 接收进程日志2：" , string, "");


	if (CheckIP(iFd) != 1){
		Status = 1;
		Nums2 = 0;
		pasTcpResponse(iFd,psMsgHead,NULL, /* 密钥，暂时不用  */ 3,
					 "compid",   UT_TYPE_LONG,   compid,
					 "Status",   UT_TYPE_STRUCT,  &Status, 1,
					 "Nums",     UT_TYPE_LONG,     Nums2);

		recodeLogInfo("进程日志：","过滤该信息", "");
		return 0;			
	}

	if( (compid == 0)){
		Status = -3;
		Nums2 = 0;

		pasTcpResponse(iFd,psMsgHead,NULL, /* 密钥，暂时不用  */ 3,
					 "compid",   UT_TYPE_LONG,   compid,
					 "Status",   UT_TYPE_STRUCT,  &Status, 1,
					 "Nums",     UT_TYPE_LONG,     Nums2);

		recodeLogInfo("进程日志：","compid为空", "");
		return -1;

	}
	
	//动态开辟存储空间
	data = (char *)malloc(PACKAGE_MAXLEN);
	if(!data){
		Status = -4;
		Nums2 = 0;

		pasTcpResponse(iFd,psMsgHead,NULL, /* 密钥，暂时不用  */ 3,
					 "compid",   UT_TYPE_LONG,   compid,
					 "Status",   UT_TYPE_STRUCT,  &Status, 1,
					 "Nums",     UT_TYPE_LONG,     Nums2);

		recodeLogInfo("进程日志：" , "动态开辟空间失败！", "");
		return -1;
	}else{
		memset(data, 0, PACKAGE_MAXLEN);
	}


	int   Numbers = 0;
	char  str[20][50];
	char  conver[50];
	memset(str, 0, 20*50);
	memset(conver, 0, sizeof(conver));

	//查询当前客户端信息
	nwCompInfo *psComp = (nwCompInfo *)utShmHashLook(psShmHead,NC_LNK_COMPUTE,&compid);
	
	char sql[256];
	memset(sql, 0, sizeof(sql));
	
	sprintf(sql,"select groupid from nwgroup where compid=%lu",compid);
	
	pasDbOneRecord(sql,0,UT_TYPE_ULONG,sizeof(groupid2),&groupid2);


	for(Numbers = 0; Numbers < Nums; Numbers++)
	{
		snprintf(str[0], 50, "mac%d", Numbers);
		snprintf(str[1], 50, "groupid%d", Numbers);		
		snprintf(str[2], 50, "devname%d", Numbers);
		snprintf(str[3], 50, "username%d", Numbers);
		snprintf(str[4], 50, "sip%d", Numbers);
		snprintf(str[5], 50, "procname%d", Numbers);
		snprintf(str[6], 50, "screenid", Numbers);
		snprintf(str[7], 50, "Mark%d", Numbers);
		snprintf(str[8], 50, "Pid%d", Numbers);
		snprintf(str[9], 50, "Indexid%d", Numbers);		
		snprintf(str[10], 50, "Pindexid%d", Numbers);
		snprintf(str[11], 50, "Stime%d", Numbers);
		snprintf(str[12], 50, "Btime%d", Numbers);
		snprintf(str[13], 50, "Path%d", Numbers);
		snprintf(str[14], 50, "mem%d", Numbers);
		snprintf(str[15], 50, "cpu%d", Numbers);
		snprintf(str[16], 50, "flags%d", Numbers);
		snprintf(str[17], 50, "nettime%d", Numbers);
		snprintf(str[18], 50, "wndtime%d", Numbers);

		iReturn = utMsgGetSomeNVar(psMsgHead,19,
					     	str[0],  UT_TYPE_STRING,sizeof(mac)-1, mac,
						str[1],  UT_TYPE_LONG,   4,  &groupid,
						str[2], UT_TYPE_STRING,  sizeof(devname)-1,  devname,
						str[3], UT_TYPE_STRING, sizeof(username)-1,username,
						str[4], UT_TYPE_LONG,   4,  &sip,
						str[5], UT_TYPE_STRING, sizeof(procname)-1, procname,
						str[6], UT_TYPE_LONG, 4, &screenid,
						str[7], UT_TYPE_STRUCT,   1, &Mark,
						str[8], UT_TYPE_LONG,   4,  &Pid,
						str[9], UT_TYPE_STRING, sizeof(Indexid)-1, Indexid,
						str[10], UT_TYPE_STRING, sizeof(Pindexid)-1, Pindexid,
						str[11], UT_TYPE_LONG,   4,  &Stime,
						str[12], UT_TYPE_LONG,   4,  &Btime,
						str[13], UT_TYPE_STRING, sizeof(Path)-1,Path,
						str[14], UT_TYPE_LONG, 4,&mem,
						str[15], UT_TYPE_LONG, 4,&cpu,
						str[16], UT_TYPE_LONG, 4,&flags,
						str[17], UT_TYPE_LONG, 4,&nettime,
						str[18], UT_TYPE_LONG, 4,&wndtime 
						);
		if( (strlen(mac)<=0 ) &&
		(groupid == 0)&&
		(strlen(devname) <=0) &&
		(strlen(username)<=0)&&
		(sip==0)&&
		(strlen(procname)<=0) &&
		(Mark == 0)&&
		(Pid == 0)&&
		(strlen(Indexid))&&
		(strlen(Pindexid))&&
		(Stime == 0)&&
		(Btime == 0)&&
		(strlen(Path) <=0)&&
		(mem==0) &&
		(cpu==0) &&
		(flags == 0)){
			recodeLogInfo("收到一条空进程日志","", "");
			Nums2++;
			continue;					
		}


		char mystring[512];
		memset(mystring, 0, sizeof(mystring));
		snprintf(mystring, sizeof(mystring)-1, " compid=%u, stime=%u", compid, Stime);

		if(sip == 0){
			recodeLogInfo(" 收到一条进程日志:", mystring, "sip == 0");
		}
		if(Stime == 0){
			recodeLogInfo(" 收到一条进程日志:",  mystring, "Stime == 0");
		}
		if(Btime == 0){
			recodeLogInfo(" 收到一条进程日志:",  mystring, "Btime == 0");
		}
		if(strlen(Indexid) <= 0 ){
			recodeLogInfo(" 收到一条进程日志:",  mystring, "Indexid == NULL");
		}
		if(strlen(Pindexid) <= 0 ){
			recodeLogInfo(" 收到一条进程日志:",  mystring, "Pindexid == NULL");
		}	
		if( strlen(Path) <= 0){
			recodeLogInfo(" 收到一条进程日志:",  mystring, "Path == NULL");
		}


		//保存数据到文件中
		unsigned long long currentTime = pasGetLongTimeId(); //获取时间
		if(psComp != NULL){
			userid = psComp->userid;
			groupid= psComp->groupid;
		}
		groupid = groupid2;											
			
		int i;
		for(i = 0; i < strlen(Path);   i++){
			if(Path[i] == '\\')
				Path[i]  = '/';

		}

		if(screenid == -1){
			screenid = 0;
		}

		snprintf(data+strlen(data),PACKAGE_MAXLEN-strlen(data)-1,   "%llu\t%u\t%u\t%s\t"
					"%u\t%s\t%s\t%u\t"
					"%s\t%d\t%d\t%d\t%s\t"
					"%s\t%u\t%u\t%s\t"
					"%d\t%d\t%d\t%d\t%d\n",
					currentTime, compid,      userid ,    mac,
					groupid,     devname,     username,   sip,     
					procname,    screenid, 	 Mark,       Pid,     Indexid, 
					Pindexid,    Stime,       Btime,      Path,
					mem,         cpu,         flags,      nettime,   wndtime
					);

		Nums2++;

	}// end for()

		
	//监测记录的Nums2的值是否和Nums相等
	char  mesg[512];
	memset(mesg, 0, sizeof(mesg));
	snprintf(mesg, sizeof(mesg)-1, "compid=%u, userid=%d, Nums=%d, success=%d", compid, userid, Nums, Nums2);
	if(Nums != Nums2){
		Status= -3;
		Nums2 = 0;
		recodeLogInfo("进程日志：Error(Nums != success):", mesg,"");

	}else{
		//创建当天日志目录,并将创建?哪柯即娣诺dir中，以便后面使用该目录
		createDir(dir,  sizeof(dir));

		//查询当前数据应该保存在哪个文件中， 如果查询成功，则打开此文件,失败则返回错误
		if(searchPos2(userid, "nwproclog",dir, savefile, sizeof(dir))) {
			Status = -4;
			Nums2 = 0;
			recodeLogInfo("进程日志：Error:", "查找存储文件失败！","");
		}else{      
			if( (fp = fopen(savefile, "a+")) == NULL) { //打开存储文件失败
				Status  = -5;
				Nums2 = 0;
				recodeLogInfo("进程日志：Error:", "打开存储文件失败！",savefile);
			}else{	//打开文件成功，则保存数据到文件中
				//给文件加锁
				pasFileSetFileLock(fp);

				fwrite(data, 1,strlen(data) ,  fp);

				//给文件解锁
				pasFileSetFileUnLock(fp);

				fclose(fp);
				fp = NULL;

				Status = 1;

			}		
		}		
		recodeLogInfo(" 接收进程日志3：" , mesg, "");		
	}


	pasTcpResponse(iFd,psMsgHead,NULL, /* 密钥，暂时不用  */ 3,
					 "compid",   UT_TYPE_LONG,   compid,
					 "Status",   UT_TYPE_STRUCT,  &Status, 1,
					 "Nums",     UT_TYPE_LONG,     Nums2);
	free(data);
	return 0;
}

//3、外设活动日志上传
int  Lan_RmoveLog_Up(utShmHead *psShmHead, int iFd,utMsgHead *psMsgHead)
{
	unsigned int   Nums   = 0;
	unsigned int   compid = 0;
	unsigned int   userid = 0;
	char  mac[50];
	unsigned int   groupid = 0;
	unsigned int 	groupid2 = 0;
	char  devname[50];
	char  username[50];
	unsigned int   sip  = 0;
	char  procname[100];

	char  Mark = '\0';
	unsigned int   Stime= 0;
	char  Valuename[128];
	char  Produname[128];
	char  Hardname[128];
	char  Driversn[24];

	char  Status = 0;
	int   Nums2 = 0;
	long  iReturn= 0;
	FILE   *fp = NULL;
	char     *data = NULL;

	char dir[512]; //保存目录
	char savefile[512];  //保存的文件名	
	utMsgPrintMsg(psMsgHead);

	char  	     sql[2048];
	pasDbCursor *psCur = NULL;
	memset(sql,0, sizeof(sql));


	memset(mac, 0, sizeof(mac));
	memset(devname, 0, sizeof(devname));
	memset(username, 0, sizeof(username));
	memset(procname, 0, sizeof(procname));
	memset(Valuename, 0, sizeof(Valuename));
	memset(Produname, 0, sizeof(Produname));
	memset(Hardname, 0, sizeof(Hardname));
	memset(Driversn,  0, sizeof(Driversn));

	memset(dir,  0, sizeof(dir));
	memset(savefile, 0, sizeof(savefile));

	

    	iReturn = utMsgGetSomeNVar(psMsgHead,3,
		                        "compid",  UT_TYPE_ULONG,  4, &compid,
					"userid",  UT_TYPE_ULONG,  4, &userid,
					"Nums",    UT_TYPE_LONG,  4, &Nums
					);

	if (CheckIP(iFd) != 1){
		Status = 1;
		Nums2 = Nums;
		pasTcpResponse(iFd,psMsgHead,NULL, /* 密钥，暂时不用  */ 3,
					 "compid",   UT_TYPE_LONG,   compid,
					 "Status",   UT_TYPE_STRUCT,  &Status, 1,
					 "Nums",     UT_TYPE_LONG,     Nums2);

		recodeLogInfo("外设日志：","过滤该信息", "");
		return 0;			
	}


	if( (compid == 0)){
		Status = -1;
		Nums2 = 0;

		pasTcpResponse(iFd,psMsgHead,NULL, /* 密钥，暂时不用  */ 3,
					 "compid",   UT_TYPE_LONG,   compid,
					 "Status",   UT_TYPE_STRUCT,  &Status, 1,
					 "Nums",     UT_TYPE_LONG,     Nums2);

		recodeLogInfo("外设日志：","compid为空", "");
		return -1;
	}

	//动态开辟存储空间
	data = (char *)malloc(PACKAGE_MAXLEN);
	if(!data){
		Status = -2;
		Nums2 = 0;

		pasTcpResponse(iFd,psMsgHead,NULL, /* 密钥，暂时不用  */ 3,
					 "compid",   UT_TYPE_LONG,   compid,
					 "Status",   UT_TYPE_STRUCT,  &Status, 1,
					 "Nums",     UT_TYPE_LONG,     Nums2);

		recodeLogInfo("外设日志：" , "动态开辟空间失败！", "");
		return -1;
	}else{
		memset(data, 0, PACKAGE_MAXLEN);
	}

	//提取信息
	int   Numbers = 0;
	char  str[12][50];
	memset(str, 0, 12*50);

	//查询当前客户端信息
	nwCompInfo *psComp = (nwCompInfo *)utShmHashLook(psShmHead,NC_LNK_COMPUTE,&compid);
	char Mysql[256];
	memset(Mysql, 0, sizeof(Mysql));
	
	sprintf(Mysql,"select groupid from nwgroup where compid=%lu",compid);
	
	pasDbOneRecord(Mysql,0,UT_TYPE_ULONG,sizeof(groupid2),&groupid2);


	for(Numbers = 0; Numbers < Nums; Numbers++)
	{
		snprintf(str[0], 50, "mac%d", Numbers);
		snprintf(str[1], 50, "groupid%d", Numbers);		
		snprintf(str[2], 50, "devname%d", Numbers);
		snprintf(str[3], 50, "username%d", Numbers);
		snprintf(str[4], 50, "sip%d", Numbers);
		snprintf(str[5], 50, "procname%d", Numbers);
		snprintf(str[6], 50, "Mark%d", Numbers);
		snprintf(str[7], 50, "Stime%d", Numbers);
		snprintf(str[8], 50, "Valuename%d", Numbers);		
		snprintf(str[9], 50, "Produname%d", Numbers);
		snprintf(str[10], 50, "Hardname%d", Numbers);
		snprintf(str[11], 50, "Driversn%d", Numbers);


		iReturn = utMsgGetSomeNVar(psMsgHead,12,
						str[0],  UT_TYPE_STRING,sizeof(mac)-1, mac,
						str[1],  UT_TYPE_LONG,   4,  &groupid,
						str[2], UT_TYPE_STRING,  sizeof(devname)-1,  devname,
						str[3], UT_TYPE_STRING, sizeof(username)-1,username,
						str[4], UT_TYPE_LONG,   4,  &sip,
						str[5], UT_TYPE_STRING, sizeof(procname)-1, procname,
						str[6], UT_TYPE_STRUCT,   1, &Mark,
						str[7], UT_TYPE_LONG,   4,  &Stime,
						str[8],  UT_TYPE_STRING, sizeof(Valuename)-1, Valuename,
						str[9],  UT_TYPE_STRING, sizeof(Produname)-1, Produname,
						str[10],  UT_TYPE_STRING, sizeof(Hardname)-1, Hardname,
						str[11],  UT_TYPE_STRING, sizeof(Driversn)-1,  Driversn
						);
		if( (strlen(mac)<=0 ) &&
		(groupid == 0)&&
		(strlen(devname) <=0) &&
		(strlen(username)<=0)&&
		(sip==0)&&
		(strlen(procname)<=0) &&
		(Mark == 0)&&
		(Stime == 0)&&
		(strlen(Valuename) <=0)&&
		(strlen(Produname) <=0)&&
		(strlen(Hardname) <=0)&&
		(strlen(Driversn) <=0)){
			recodeLogInfo(" 收到一条空外设日志","", "");
			Nums2++;
			continue;					
		}

		if(Mark == 0){//出错信息
			recodeLogInfo(" 收到一条错误外设日志.....","", "");
		}else if(Mark == 100){//USB实时信息		
			//把新信息更新到nwusblist表中
			if(strlen(Hardname) > 0){
				char  string[512];
				memset(string, 0, sizeof(string));	

				snprintf(sql, sizeof(sql)-1, "select compid  from nwusblist  where hardid=\'%s\'  ",   Hardname);
				pasDbCursor *psCur = pasDbOpenSql(sql,0);
    				if(psCur == NULL) { //查询数据库失败，记录日志
					snprintf(string, sizeof(string)-1, "hardid=%s, stime=%u, compid=%u ,Do SQL Error, sqlcode is  %d ",  Hardname, Stime, compid,  pasDbSqlCode(NULL));
        					recodeLogInfo("从nwusblist数据表中查询数据失败！" ,string , sql);
        		    		}else{ 
					int     sqlCompid = 0;
					iReturn = pasDbFetchInto(psCur,  UT_TYPE_LONG, 4 , &sqlCompid);
					pasDbCloseCursor(psCur);
					if((iReturn==0)  && (sqlCompid !=0)){//如果查询到记录，则更新该条记录
						snprintf(sql , sizeof(sql)-1, " update  nwusblist  set  name=\'%s\',  produname=\'%s\',  volname=\'%s\',  sip=%u, compid=%u,  stime=%u  where hardid=\'%s\' ; ",  
							Valuename,  Produname, Driversn, sip, compid, Stime,  Hardname);
						
						if(pasDbExecSql(sql, 0) != 0){
							snprintf(string, sizeof(string)-1, "sizeof(sql)= %d, hardid=%s, stime=%u, compid=%u ,Do SQL Error, sqlcode is  %d ", sizeof(sql), Hardname, Stime, compid,  pasDbSqlCode(psCur));
							recodeLogInfo("从nwusblist数据表中更新数据失败！" ,string , sql);
						}
					}else{//如果没查到记录，则插入一条记录
						snprintf(sql, sizeof(sql)-1, "insert into nwusblist(name, produname, volname, hardid, sip, compid, stime)  values(\'%s\', \'%s\', \'%s\', \'%s\',  %u, %u, %u)",\
									Valuename,  Produname,  Driversn, Hardname, sip, compid, Stime);
						if(pasDbExecSql(sql, 0)){
							snprintf(string, sizeof(string)-1, "hardid=%s, stime=%u, compid=%u ,Do SQL Error, sqlcode is  %d ",  Hardname, Stime, compid,  pasDbSqlCode(NULL));
							recodeLogInfo("插入记录到nwusblist数据表中失败！", string, sql);        					
						}
					}
				}				
			}
		}else{//外设日志信息								
			char mystring[512];
			memset(mystring, 0, sizeof(mystring));
			snprintf(mystring, sizeof(mystring)-1, " compid=%u, stime=%u", compid, Stime);

			if(sip == 0){
				recodeLogInfo(" 收到一条外设日志",mystring, "ip = 0");
			}				
			if(Stime == 0){
				recodeLogInfo(" 收到一条外设日志:", mystring, "Stime == 0");
			}
			if(strlen(Valuename) <= 0 ){
				recodeLogInfo(" 收到一条外设日志:", mystring, "Valuename== NULL");
			}
			if(strlen(Produname) <= 0 ){
				recodeLogInfo(" 收到一条外设日志:", mystring, "Produname== NULL");
			}	
			if( strlen(Hardname) <= 0){
				recodeLogInfo(" 收到一条外设日志:", mystring, "Hardname== NULL");
			}
			if( strlen(Driversn) <= 0){
				recodeLogInfo(" 收到一条外设日志:", mystring, "Driversn== NULL");
			}

			//保存数据到文件中
			unsigned long long currentTime = pasGetLongTimeId(); //获取时间
			if(psComp != NULL){
				userid = psComp->userid;
				groupid= psComp->groupid;
			}
			groupid = groupid2;

			snprintf(data+strlen(data),PACKAGE_MAXLEN-strlen(data)-1, "%llu\t%u\t%u\t%s\t"
					"%u\t%s\t%s\t%u\t"
					"%s\t%d\t%u\t%s\t"
					"%s\t%s\t%s\n",
					currentTime,    compid,      userid ,        mac,
					groupid,          devname,    username,    sip,
					procname,      Mark,          Stime,         Valuename, 
					Produname,    Hardname,  Driversn
					);
		}
		Nums2++;
	}//end for()


	//监测记录的Nums2的值是否和Nums相等
	char  mesg[512];
	memset(mesg, 0, sizeof(mesg));
	snprintf(mesg, sizeof(mesg)-1, "compid=%u, userid=%d, Nums=%d, success=%d,data=%s", compid, userid, Nums, Nums2, data);
	if(Nums != Nums2){
		Status= -3;
		Nums2 = 0;
		recodeLogInfo("外设日志：Error(Nums != success):", mesg,"");

	}else{
		Status = 1;
		if(strlen(data) > 0){

			//创建当天日志目录,并将创建?哪柯即娣诺dir中，?员愫竺媸褂?媚柯?
			createDir(dir,  sizeof(dir));

			//查询当前数据应该保存在?母鑫募中?如果查询成功，则打开此文件,失败则返回错误
			if(searchPos2(userid, "nwremovelog",dir, savefile, sizeof(dir))) {
				Status = -4;
				Nums2 = 0;
				recodeLogInfo("外设日志：Error:", "查找存储文件失败！","");
			}else{      
				if( (fp = fopen(savefile, "a+")) == NULL) { //打开存储文件失败
					Status  = -5;
					Nums2 = 0;
					recodeLogInfo("外设日志：Error:", "打开存储文件失败！",savefile);
				}else{	//打开文件成功，则保存数据到文件中
				
					pasFileSetFileLock(fp);//给文件加锁

					int len = fwrite(data, 1,strlen(data) ,  fp);

					fseek(fp, 0, SEEK_END);
					int len3 = ftell(fp);
					
					pasFileSetFileUnLock(fp);//给文件解锁

					close(fp);
				}
			}
		}		
		recodeLogInfo(" 接收外设日志3：" , mesg, "");		
	}
	//printf("------------------------------------receive process log, compid = %u, Status = %d, Nums = %d, Nums2 = %d\n", compid, Status,  Nums, Nums2);

	pasTcpResponse(iFd,psMsgHead,NULL, /* 密钥，暂时不用  */ 3,
					 "compid",   UT_TYPE_LONG,    compid,
					 "Status",   UT_TYPE_STRUCT,  &Status, 1,
					 "Nums",     UT_TYPE_LONG,     Nums2);
	free(data);
	return 0;
}

//4、网页?罩旧洗?
int  Lan_WebLog_Up(utShmHead *psShmHead, int iFd,utMsgHead *psMsgHead)
{
	unsigned int   Nums   = 0;
	unsigned int   compid = 0;
	unsigned int   userid = 0;
	char  mac[50];
	unsigned int   groupid = 0;
	unsigned int	groupid2 = 0;
	char  devname[50];
	char  username[50];
	unsigned int   sip  = 0;
	char  procname[100];

	unsigned int   Stime = 0;
	unsigned int      urlClass = 0;
	char  Webaddr[129];
	char  Subject[129];
	char  Content[129];
	char  Host[129];

	char  Status = 0;
	int   Nums2 = 0;
	long  iReturn= 0;
	FILE   *fp = NULL;
	char     *data = NULL;

	char dir[512]; //保存目录
	char savefile[512];  //保存的文??
	//utMsgPrintMsg(psMsgHead);

	memset(mac, 0, sizeof(mac));
	memset(devname, 0, sizeof(devname));
	memset(username, 0, sizeof(username));
	memset(procname, 0, sizeof(procname));
	memset(Webaddr, 0, sizeof(Webaddr));
	memset(Subject, 0, sizeof(Subject));
	memset(Content, 0, sizeof(Content));
	memset(dir,  0, sizeof(dir));
	memset(savefile, 0, sizeof(savefile));

	//创建当天日志目录,并将创建的目录存放到dir中，以?愫竺媸褂酶媚柯?
	createDir(dir,  300);

   	iReturn = utMsgGetSomeNVar(psMsgHead,3,
		                        "compid",  UT_TYPE_ULONG,  4,  &compid,
					"userid",  UT_TYPE_ULONG,  4,  &userid,
					"Nums",    UT_TYPE_LONG,  4,  &Nums
					);

	if (CheckIP(iFd) != 1){
		Status = 1;
		Nums2 = Nums;

		pasTcpResponse(iFd,psMsgHead,NULL, /* 密钥，暂时不用  */ 3,
					 "compid",   UT_TYPE_LONG,   compid,
					 "Status",   UT_TYPE_STRUCT,  &Status, 1,
					 "Nums",     UT_TYPE_LONG,     Nums2);

		recodeLogInfo("网页日志：","过滤该信息", "");
		return 0;			
	}

	if( (compid == 0)){
		Status = -2;
		Nums2 = 0;

		pasTcpResponse(iFd,psMsgHead,NULL, /* 密钥，暂时不用  */ 3,
					 "compid",   UT_TYPE_LONG,   compid,
					 "Status",   UT_TYPE_STRUCT,  &Status, 1,
					 "Nums",     UT_TYPE_LONG,     Nums2);

		recodeLogInfo("网页日志：","compid为空", "");
		return -1;
	}
	
	//动态开辟存储空间
	data = (char *)malloc(PACKAGE_MAXLEN);
	if(!data){
		Status = -3;
		Nums2 = 0;

		pasTcpResponse(iFd,psMsgHead,NULL, /* ?茉浚暂时不? */ 3,
					 "compid",   UT_TYPE_LONG,   compid,
					 "Status",   UT_TYPE_STRUCT,  &Status, 1,
					 "Nums",     UT_TYPE_LONG,     Nums2);

		recodeLogInfo("网页日志：" , "动态开辟空间失败！", "");
		return -1;
	}else{
		memset(data, 0, PACKAGE_MAXLEN);
	}

	//提取信息
	int   Numbers = 0;
	char  str[11][50];
	memset(str, 0, 11*50);
			
	//查询当前客户端信息
	nwCompInfo *psComp = (nwCompInfo *)utShmHashLook(psShmHead,NC_LNK_COMPUTE,&compid);

	char sql[256];
	memset(sql, 0, sizeof(sql));
	
	sprintf(sql,"select groupid from nwgroup where compid=%lu",compid);
	
	pasDbOneRecord(sql,0,UT_TYPE_ULONG,sizeof(groupid2),&groupid2);

	for(Numbers = 0; Numbers < Nums; Numbers++)
	{
		snprintf(str[0], 50, "mac%d", Numbers);
		snprintf(str[1], 50, "groupid%d", Numbers);		
		snprintf(str[2], 50, "devname%d", Numbers);
		snprintf(str[3], 50, "username%d", Numbers);
		snprintf(str[4], 50, "sip%d", Numbers);
		snprintf(str[5], 50, "procname%d", Numbers);
		snprintf(str[6], 50, "Stime%d", Numbers);
		snprintf(str[7], 50, "urlClass%d", Numbers);
		snprintf(str[8], 50, "Webaddr%d", Numbers);
		snprintf(str[9], 50, "Subject%d", Numbers);
		snprintf(str[10], 50, "Content%d", Numbers);
			
		iReturn = utMsgGetSomeNVar(psMsgHead,11,
						str[0],  UT_TYPE_STRING,sizeof(mac)-1, mac,
						str[1],  UT_TYPE_LONG,   4,  &groupid,
						str[2], UT_TYPE_STRING,  sizeof(devname)-1,  devname,
						str[3], UT_TYPE_STRING, sizeof(username)-1,username,
						str[4], UT_TYPE_LONG,   4,  &sip,
						str[5], UT_TYPE_STRING, sizeof(procname)-1, procname,
						str[6], UT_TYPE_LONG,   4,  &Stime,
						str[7], UT_TYPE_LONG,   4,  &urlClass,
						str[8], UT_TYPE_STRING, sizeof(Webaddr)-1,Webaddr,
						str[9], UT_TYPE_STRING, sizeof(Subject)-1,Subject,
						str[10], UT_TYPE_STRING, sizeof(Content)-1,Content
						);
	/*
		if( (strlen(mac)<=0 ) &&
		(groupid == 0)&&
		(strlen(devname) <=0) &&
		(strlen(username)<=0)&&
		(strlen(procname)<=0) &&
		(Stime == 0)&&
		(urlClass==0)&&
		(strlen(Webaddr) <=0)&&
		(strlen(Subject) <=0)){
			recodeLogInfo("收到一条空网页日志","", "");
			Nums2++;
			continue;					
		}
				
	*/			
		char mystring[512];
		memset(mystring, 0, sizeof(mystring));
		snprintf(mystring, sizeof(mystring)-1, " compid=%u, stime=%u", compid, Stime);
		if(sip == 0){
			recodeLogInfo(" 收?揭惶跬页日?",mystring,  "ip = 0");
		}			
		if(Stime == 0){
			recodeLogInfo(" 收到一条网页日志:", mystring,  "Stime == 0");
		}
		if(strlen(Webaddr) <= 0 ){
			recodeLogInfo(" 收到一条网页日志:", mystring,  "Webaddr== NULL");
			//Nums2++;
			//continue;
		}
		if(strlen(Subject) <= 0 ){
			recodeLogInfo(" 收到一条网页日志:", mystring,  "Subject== NULL");
		}


		//保存数据到文件中
		unsigned long long currentTime = pasGetLongTimeId(); //获取时间
		if(psComp != NULL){
			userid = psComp->userid;
			groupid= psComp->groupid;
		}
		groupid = groupid2;

		//从Webaddr中提取host字段
		GetHost(Webaddr, Host, sizeof(Host)-1);

		snprintf(data+strlen(data), PACKAGE_MAXLEN-strlen(data)-1, "%llu\t%u\t%u\t%s\t"
					"%u\t%s\t%s\t%u\t"
					"%s\t%u\t%u\t%s\t"
					"%s\t%s\t%s\n",
					currentTime,    compid,      userid ,    mac,
					groupid,        devname,    username,    sip,
					procname,       Stime,      urlClass,    Webaddr,
					Subject,        Content,	Host   
					);

		Nums2++;

	}//end for()


	//监测记录的Nums2的?凳欠窈Nums相等
	char  mesg[512];
	memset(mesg, 0, sizeof(mesg));
	snprintf(mesg, sizeof(mesg)-1, "compid=%u, userid=%d, Nums=%d, success=%d", compid, userid, Nums, Nums2);
	if(Nums != Nums2){
		Status= -3;
		Nums2 = 0;
		recodeLogInfo("网页日志：Error(Nums != success):", mesg,"");

	}else{
		//创建当天日志目录,并将创建?哪柯即娣诺dir中，以便后面使用该目录
		createDir(dir,  sizeof(dir));

		//查询当前数据应该保存在哪个文件中， 如果查询成功，则打开此文件,失败则返回错误
		if(searchPos2(userid, "nwweblog",dir, savefile, sizeof(dir))) {
			Status = -4;
			Nums2 = 0;
			recodeLogInfo("网页日志：Error:", "查找存储文件失败！","");
		}else{      
			if( (fp = fopen(savefile, "a+")) == NULL) { //打开存储文件失败
				Status  = -5;
				Nums2 = 0;
				recodeLogInfo("网页日志：Error:", "打开存储文件失败！",savefile);
			}else{	//打开文件成功，则保存数据到文件中
				//给文件加锁
				pasFileSetFileLock(fp);

				fwrite(data, 1,strlen(data) ,  fp);

				//给文件解锁
				pasFileSetFileUnLock(fp);

				fclose(fp);
				fp = NULL;

				FILE * ff = fopen("/home/ncmysql/nw/temp/web.log", "a+");
				if(ff){
					fwrite(data, 1,strlen(data) ,  ff);
					fclose(ff);
				}

				Status = 1;
			}		
		}		
		recodeLogInfo(" 接收网页日志3：" , mesg, "");		
	}


	pasTcpResponse(iFd,psMsgHead,NULL, /* 密钥，暂时不用  */ 3,
					 "compid",   UT_TYPE_LONG,    compid,
					 "Status",   UT_TYPE_STRUCT,  &Status, 1,
					 "Nums",     UT_TYPE_LONG,    Nums2);
	free(data);
	return 0;
}

//5、聊天日志上传
int  Lan_ChatLog_Up(utShmHead *psShmHead, int iFd,utMsgHead *psMsgHead)
{
	unsigned int   Nums   = 0;
	unsigned int   compid = 0;
	unsigned int   userid = 0;
	char  mac[50];
	unsigned int   groupid = 0;
	unsigned int	groupid2 = 0;
	char  devname[50];
	char  username[50];
	unsigned int   sip  = 0;
	char  procname[100];

	unsigned int   Stime  = 0;
	int   Service= 0;
	int   Funcode= 0;
	char  Mfrom[50];
	char  Mto[50];
	char  Mesg[256];
	char  Myaccount[50];
	char  Friendaccount[50];

	char  Status = 0;
	int   Nums2 = 0;
	long  iReturn= 0;
	FILE   *fp = NULL;
	char      *data = NULL;

	char dir[300]; //保存目录
	char savefile[300];  //?４娴奈募?
	//utMsgPrintMsg(psMsgHead);

	memset(mac, 0, sizeof(mac));
	memset(devname, 0, sizeof(devname));
	memset(username, 0, sizeof(username));
	memset(procname, 0, sizeof(procname));
	memset(Mfrom, 0, sizeof(Mfrom));
	memset(Mto, 0, sizeof(Mto));
	memset(Mesg,  0,  sizeof(Mesg));
	memset(Myaccount,  0, sizeof(Myaccount));
	memset(Friendaccount,  0, sizeof(Friendaccount));
	memset(dir,  0, sizeof(dir));
	memset(savefile, 0, sizeof(savefile));

	//创建当天日志目录,并将创建的目录存放?dir中，以便?竺媸褂酶媚柯?
	createDir(dir,  300);

    	iReturn = utMsgGetSomeNVar(psMsgHead,3,
		                        "compid",  UT_TYPE_ULONG,  4, &compid,
					"userid",  UT_TYPE_ULONG,  4, &userid,
					"Nums",    UT_TYPE_LONG,  4, &Nums
					);

	if (CheckIP(iFd) != 1){
		Status = 1;
		Nums2 = Nums;
		pasTcpResponse(iFd,psMsgHead,NULL, /* 密钥，暂时不用  */ 3,
					 "compid",   UT_TYPE_LONG,   compid,
					 "Status",   UT_TYPE_STRUCT,  &Status, 1,
					 "Nums",     UT_TYPE_LONG,     Nums2);

		recodeLogInfo("聊天日志：","过滤该信息", "");
		return 0;			
	}


	if( (compid == 0) ){
		Status = -3;
		Nums2 = 0;

		pasTcpResponse(iFd,psMsgHead,NULL, /* 密钥，暂时不用  */ 3,
					 "compid",   UT_TYPE_LONG,   compid,
					 "Status",   UT_TYPE_STRUCT,  &Status, 1,
					 "Nums",     UT_TYPE_LONG,     Nums2);

		recodeLogInfo("聊天日志：","compid为空", "");
		return -1;
	}

	//动态开辟存储空间
	data = (char *)malloc(PACKAGE_MAXLEN);
	if(!data){
		Status = -4;
		Nums2 = 0;

		pasTcpResponse(iFd,psMsgHead,NULL, /* 密钥，暂时不用  */ 3,
					 "compid",   UT_TYPE_LONG,   compid,
					 "Status",   UT_TYPE_STRUCT,  &Status, 1,
					 "Nums",     UT_TYPE_LONG,     Nums2);

		recodeLogInfo("聊天日志:","动态开辟空间失败", "");
		return -1;
	}else{
		memset(data, 0, PACKAGE_MAXLEN);
	}

	//提取信??
	int   Numbers = 0;
	char  str[14][50];
	char  conver[50];
	memset(str, 0, 14*50);
	memset(conver, 0, sizeof(conver));

	//查询当前客户端信息
	nwCompInfo *psComp = (nwCompInfo *)utShmHashLook(psShmHead,NC_LNK_COMPUTE,&compid);
	char sql[256];
	memset(sql, 0, sizeof(sql));
	
	sprintf(sql,"select groupid from nwgroup where compid=%lu",compid);
	
	pasDbOneRecord(sql,0,UT_TYPE_ULONG,sizeof(groupid2),&groupid2);


	for(Numbers = 0; Numbers < Nums; Numbers++)
	{
		snprintf(str[0], 50, "mac%d", Numbers);
		snprintf(str[1], 50, "groupid%d", Numbers);		
		snprintf(str[2], 50, "devname%d", Numbers);
		snprintf(str[3], 50, "username%d", Numbers);
		snprintf(str[4], 50, "sip%d", Numbers);
		snprintf(str[5], 50, "procname%d", Numbers);

		snprintf(str[6], 50, "Stime%d", Numbers);
		snprintf(str[7], 50, "Service%d", Numbers);
		snprintf(str[8], 50, "Funcode%d", Numbers);		
		snprintf(str[9], 50, "Mfrom%d", Numbers);
		snprintf(str[10], 50, "Mto%d", Numbers);
		snprintf(str[11], 50, "Mesg%d", Numbers);
		snprintf(str[12], 50, "Myaccount%d", Numbers);
		snprintf(str[13], 50, "Friendaccount%d", Numbers);

		iReturn = utMsgGetSomeNVar(psMsgHead,14,
						str[0],  UT_TYPE_STRING,sizeof(mac)-1, mac,
						str[1],  UT_TYPE_LONG,   4,  &groupid,
						str[2], UT_TYPE_STRING,  sizeof(devname)-1,  devname,
						str[3], UT_TYPE_STRING, sizeof(username)-1,username,
						str[4], UT_TYPE_LONG,   4,  &sip,
						str[5], UT_TYPE_STRING, sizeof(procname)-1, procname,
						str[6], UT_TYPE_LONG,   4,  &Stime,
						str[7], UT_TYPE_LONG,   4,  &Service,
						str[8], UT_TYPE_LONG,   4,  &Funcode ,
						str[9], UT_TYPE_STRING, sizeof(Mfrom)-1, Mfrom,
						str[10], UT_TYPE_STRING, sizeof(Mto)-1, Mto,
						str[11], UT_TYPE_STRING, sizeof(Mesg)-1, Mesg,
						str[12], UT_TYPE_STRING, sizeof(Myaccount)-1,  Myaccount,
						str[13], UT_TYPE_STRING, sizeof(Friendaccount)-1,Friendaccount 
							   );

		if( (strlen(mac)<=0 ) &&
		(groupid == 0)&&
		(strlen(devname) <=0) &&
		(strlen(username)<=0)&&
		(sip==0)&&
		(strlen(procname)<=0) &&
		(Stime == 0)&&
		(Service==0)&&
  		(Funcode==0)&&
		(strlen(Mfrom) <=0)&&
		(strlen(Mto) <=0)&&
		(strlen(Mesg) <=0)&&
		(strlen(Myaccount) <=0)&&
		(strlen(Friendaccount) <=0)){
			recodeLogInfo(" 收到一条聊天日志", "", "");
			Nums++;
			continue;					
		}

		char mystring[512];
		memset(mystring, 0, sizeof(mystring));
		snprintf(mystring, sizeof(mystring)-1, " compid=%u, stime=%u", compid, Stime);

		if(sip == 0){
			recodeLogInfo(" 收到一条聊天日志",mystring, "ip = 0");
		}				
		if(Stime == 0){
			recodeLogInfo(" 收到一条聊天日志:", mystring, "Stime == 0");
		}
		if(strlen(mac) <= 0 ){
			recodeLogInfo(" 收到一条聊天日志:", mystring, "mac== NULL");
		}
		if(strlen(Mfrom) <= 0 ){
			recodeLogInfo(" 收到一条聊天日志:", mystring, "Mfrom== NULL");
		}
		if( strlen(Mto) <= 0){
			recodeLogInfo(" 收到一条聊天日志:", mystring, "Mto== NULL");
		}
		if( strlen(Mesg) <= 0){
			recodeLogInfo(" 收到一条聊天日志:", mystring, "Mesg== NULL");
		}
		if( strlen(Myaccount) <= 0){
			recodeLogInfo(" 收到一条聊天日志:", mystring, "Myaccount== NULL");
		}
		if( strlen(Friendaccount ) <= 0){
			recodeLogInfo(" 收到一条聊天日志:", mystring, "Friendaccount == NULL");
		}

	
		//保存数据到文件中
		unsigned long long currentTime = pasGetLongTimeId(); //获取时间
		if(psComp != NULL){
			userid = psComp->userid;
			groupid= psComp->groupid;
		}
		groupid = groupid2;

				
		int x = 0;
		int    length = strlen(Mesg);
		for(x = 0;  x < length;  x++){
			if( (Mesg[x] == '\n') || (Mesg[x] == '\r') || (Mesg[x] == 13)){
						Mesg[x] = '_';							
			}
		}

		//得到MD5值
		unsigned  char md5_code[512];
		unsigned  char   md5_res[64];
		memset(md5_code, 0, sizeof(md5_code)); 
		memset(md5_res, 0, sizeof(md5_res)); 

		snprintf(md5_code, sizeof(md5_code)-1, "%s%s",Mfrom, Mto);
		lan_GetMD5(md5_code, strlen(md5_code),  md5_res);
				
		snprintf(data+strlen(data), PACKAGE_MAXLEN-sizeof(data)-1,   "%llu\t%u\t%u\t%s\t"
					"%u\t%s\t%s\t%u\t"
					"%s\t%u\t%d\t%d\t"
					"%s\t%s\t%s\t%s\t"
					"%s\t%s\n",
					currentTime,    compid,      userid ,    mac,
					groupid,        devname,    username,    sip,
					procname,       Stime,      Service,    Funcode,
					Mfrom,        	Mto,        Mesg,        md5_res,
					Myaccount,     Friendaccount
					); 
				
		Nums2++;
	}//end for()


	//监测记录的Nums2的值是否和Nums相等
	char  mesg[512];
	memset(mesg, 0, sizeof(mesg));
	snprintf(mesg, sizeof(mesg)-1, "compid=%u, userid=%d, Nums=%d, success=%d", compid, userid, Nums, Nums2);
	if(Nums != Nums2){
		Status= -3;
		Nums2 = 0;
		recodeLogInfo("聊天日志：Error(Nums != success):", mesg,"");

	}else{
		//创建当天日志目录,并将创建?哪柯即娣诺dir中，以便后面使用该目录
		createDir(dir,  sizeof(dir));

		//查询当前数据应该保存在哪个文件中， 如果查询成功，则打开此文件,失败则返回错误
		if(searchPos2(userid, "ncimclient",dir, savefile, sizeof(dir))) {
			Status = -4;
			Nums2 = 0;
			recodeLogInfo("聊天日志：Error:", "查找存储文件失败！","");
		}else{      
			if( (fp = fopen(savefile, "a+")) == NULL) { //打开存储文件失败
				Status  = -5;
				Nums2 = 0;
				recodeLogInfo("聊天日志：Error:", "打开存储文件失败！",savefile);
			}else{	//打开文件成功，则保存数据到文件中
				//给文件加??
				pasFileSetFileLock(fp);

				fwrite(data, 1,strlen(data) ,  fp);
				FILE * file = fopen("/home/ncmysql/nw/char.dat",  "a+");
				if(!file){
					recodeLogInfo("记录聊天信息失败", "", "");
				}else{
					fwrite(data, 1, strlen(data), file);
					fclose(file);
				}

				//给文件解锁
				pasFileSetFileUnLock(fp);

				fclose(fp);
				fp = NULL;

				Status = 1;
			}		
		}		
		recodeLogInfo(" 接收聊天日??：" , mesg, "");		
	}

	
	//printf("聊天日志：compid= %d, Status=%d, Num = %d, SuccessNum=%d\n", compid, Status,Nums, Nums2);

	pasTcpResponse(iFd,psMsgHead,NULL, /* 密钥，暂时不用  */ 3,
					 "compid",   UT_TYPE_LONG,    compid,
					 "Status",   UT_TYPE_STRUCT,  &Status, 1,
					 "Nums",     UT_TYPE_LONG,     Nums2);
	free(data);
	return 0;
}

//6、阻?彩录上?
int  Lan_EventLog_Up(utShmHead *psShmHead,int iFd,utMsgHead *psMsgHead)
{
	unsigned int   Nums   = 0;
	unsigned int   compid = 0;
	unsigned int   userid = 0;
	char  mac[50];
	unsigned int   groupid = 0;
	unsigned int	groupid2 = 0;
	char  devname[50];
	char  username[50];
	unsigned int   sip  = 0;
	char  procname[100];

	int   Libtype  = 0;
	int   Eventtype= 0;
	int   Stime = 0;
	char  Name[50];
	char  Content[150];

	char  Status  = 0;
	int   Nums2 = 0;
	long  iReturn = 0;
	FILE   *fp = NULL;
	char dir[300]; //保存目录
	char savefile[300];  //保存的文件名	
	//utMsgPrintMsg(psMsgHead);

	memset(mac, 0, sizeof(mac));
	memset(devname, 0, sizeof(devname));
	memset(username, 0, sizeof(username));
	memset(procname, 0, sizeof(procname));
	memset(Name, 0, sizeof(Name));
	memset(Content, 0, sizeof(Content));
	memset(dir,  0, sizeof(dir));
	memset(savefile, 0, sizeof(savefile));

	//创建当天日志目录,并将创建的目录存放到dir中，以便后面使用该目录
	createDir(dir,  300);

    	iReturn = utMsgGetSomeNVar(psMsgHead,3,
		                        "compid",  UT_TYPE_ULONG,  4, &compid,
					"userid",  UT_TYPE_LONG,  4, &userid,
					"Nums",    UT_TYPE_LONG,  4, &Nums
					);

	if (CheckIP(iFd) != 1){
		Status = 1;
		Nums2 = Nums;
		pasTcpResponse(iFd,psMsgHead,NULL, /* 密钥，暂时不用  */ 3,
					 "compid",   UT_TYPE_LONG,   compid,
					 "Status",   UT_TYPE_STRUCT,  &Status, 1,
					 "Nums",     UT_TYPE_LONG,     Nums2);
		recodeLogInfo("阻挡事件日志：","过滤该信息", "");
		return 0;			
	}


	if( (compid == 0) && (userid == 0)){
		Status = 0;
		Nums2 = -3;
		recodeLogInfo("阻挡事件日志：","compid为空", "");

		pasTcpResponse(iFd,psMsgHead,NULL, /* 密钥，暂时不用  */ 3,
					 "compid",   UT_TYPE_LONG,   compid,
					 "Status",   UT_TYPE_STRUCT,  &Status, 1,
					 "Nums",     UT_TYPE_LONG,     Nums2);
		return -1;
	}

	//查询当前?据应该保存在哪个文件??如果查询成功，则打开此文件
	if(!searchPos2(userid, "nweventlog",dir, savefile, 300)) 
	{      
		if( (fp = fopen(savefile, "a+")) != NULL) //打开文件成功，则保存数据到文件中
		{	
			//给文件加锁
			pasFileSetFileLock(fp);

			int   Numbers = 0;
			char  str[12][50];
			char  conver[50];
			memset(str, 0, 12*50);
			memset(conver, 0, sizeof(conver));

			//查询?鼻翱突Ф诵??
			nwCompInfo *psComp = (nwCompInfo *)utShmHashLook(psShmHead,NC_LNK_COMPUTE,&compid);
			char sql[256];
			memset(sql, 0, sizeof(sql));
	
			sprintf(sql,"select groupid from nwgroup where compid=%lu",compid);
	
			pasDbOneRecord(sql,0,UT_TYPE_ULONG,sizeof(groupid2),&groupid2);


			for(Numbers = 0; Numbers < Nums; Numbers++)
			{
				snprintf(str[0], 50, "mac%d", Numbers);
				snprintf(str[1], 50, "groupid%d", Numbers);		
				snprintf(str[2], 50, "devname%d", Numbers);
				snprintf(str[3], 50, "username%d", Numbers);
				snprintf(str[4], 50, "sip%d", Numbers);
				snprintf(str[5], 50, "procname%d", Numbers);

				snprintf(str[6], 50, "Libtype%d", Numbers);
				snprintf(str[7], 50, "Eventtype%d", Numbers);
				snprintf(str[8], 50, "Stime%d", Numbers);		
				snprintf(str[9], 50, "Name%d", Numbers);
				snprintf(str[10], 50, "Content%d", Numbers);

				iReturn = utMsgGetSomeNVar(psMsgHead,11,
						str[0],  UT_TYPE_STRING,sizeof(mac)-1, mac,
						str[1],  UT_TYPE_LONG,   4,  &groupid,
						str[2], UT_TYPE_STRING,  sizeof(devname)-1,  devname,
						str[3], UT_TYPE_STRING, sizeof(username)-1,username,
						str[4], UT_TYPE_LONG,   4,  &sip,
						str[5], UT_TYPE_STRING, sizeof(procname)-1, procname,
						str[6], UT_TYPE_LONG,   4, &Libtype,
						str[7], UT_TYPE_LONG,   4, &Eventtype,
						str[8], UT_TYPE_LONG,   4, &Stime,
						str[9], UT_TYPE_STRING, sizeof(Name)-1,  Name,
						str[10], UT_TYPE_STRING, sizeof(Content)-1,Content 
						 );
				if( (strlen(mac)<=0 ) &&
				    (groupid == 0)&&
				    (strlen(devname) <=0) &&
				    (strlen(username)<=0)&&
				    (sip==0)&&
				    (strlen(procname)<=0) &&
				    (Stime == 0)&&
				    (Libtype==0)&&
  				    (Eventtype==0)&&
				    (strlen(Name) <=0)&&
				    (strlen(Content) <=0)){
					recodeLogInfo("收到一条空的阻挡时间日志","", "");
					continue;					
				}


				//保存数据到文件中
				unsigned long long currentTime = pasGetLongTimeId(); //获取时间
				snprintf(conver, 50, "%llu", currentTime);
				fwrite(conver, strlen(conver), 1,fp);
				fwrite("\t" ,   1, 1,  fp);  //用“\t”将字段分开

				snprintf(conver, 50, "%u", compid);
				fwrite(conver, strlen(conver),1, fp);
				fwrite("\t" ,   1, 1,  fp);  //用“\t”将字?畏挚?

				if(psComp != NULL)
				{
					snprintf(conver, 50, "%u", psComp->userid);
					fwrite(conver, strlen(conver),1, fp);
					fwrite("\t" ,   1, 1,  fp);  //用“\t”将字段分开
				}else{
					snprintf(conver, 50, "%u", userid);
					fwrite(conver, strlen(conver),1, fp);
					fwrite("\t" ,   1, 1,  fp);  //用“\t”将字段分开

				}							

				fwrite( mac,  strlen(mac), 1, fp);
				fwrite("\t" ,   1, 1,  fp);  //用“\t”将字段分开

				
				groupid = groupid2;
				if(psComp != NULL)
				{
					snprintf(conver, 50, "%u", groupid);
					fwrite(conver, strlen(conver),1, fp);
					fwrite("\t" ,   1, 1,  fp);  //用“\t”将字段分开
				}else{
					snprintf(conver, 50, "%u", groupid);
					fwrite(conver, strlen(conver),1, fp);
					fwrite("\t" ,   1, 1,  fp);  //用“\t”将字段分开
				}	

				fwrite(devname, strlen(devname), 1, fp);
				fwrite("\t" ,   1, 1,  fp);  //用“\t”将字段分开
				
				fwrite(username,  strlen(username), 1, fp);
				fwrite("\t" ,   1, 1,  fp);  //用“\t”将字段分开
				
				snprintf(conver,50,"%u", sip);
				fwrite(conver,  strlen(conver),  1, fp);
				fwrite("\t" ,   1, 1,  fp);  //用“\t”将字段分开
				
				fwrite(procname,  strlen(procname),  1,  fp);
				fwrite("\t" ,   1, 1,  fp);  //用“\t”将字段分开

				snprintf(conver, 50, "%d", Libtype);
				fwrite(conver, strlen(conver), 1, fp);
				fwrite("\t" ,   1, 1,  fp);  //用“\t”将字段分开

				snprintf(conver, 50, "%d", Eventtype);
				fwrite(conver, strlen(conver), 1, fp);
				fwrite("\t" ,   1, 1,  fp);  //用“\t”将字段分开

				snprintf(conver, 50, "%u", Stime);
				fwrite(conver, strlen(conver), 1, fp);
				fwrite("\t" ,   1, 1,  fp);  //用“\t”将字段分开
								
				fwrite(Name,  strlen(Name), 1, fp);
				fwrite("\t" ,   1, 1,  fp);  //用“\t”将?侄?挚?

				fwrite(Content,  strlen(Content), 1, fp);
				fwrite("\n" ,   1, 1,  fp);  //用“\n”结束
				
				Nums2++;
			}//end for()

			Status = 1;

			//给文件解锁
			pasFileSetFileUnLock(fp);

			fclose(fp);
			fp = NULL;

		}//end fopen()
	}//end searchPos()

	if(Nums > Nums2){
		Nums2 = 0;
		char findError1[512];
		char findError2[512];

		memset(findError1, 0, sizeof(findError1));
		memset(findError2, 0, sizeof(findError2));

		snprintf(findError1, sizeof(findError1)-1, "compid=%u, Status = %d, Nums=%d", compid, Status, Nums);
		snprintf(findError2, sizeof(findError2)-1, "Nums2=%d", Nums2);
		recodeLogInfo("阻挡事件日志：", findError1,findError2);

	}

	//printf("阻挡事件日志：compid= %d, Status=%d, Num = %d, SuccessNum=%d\n", compid, Status,Nums, Nums2);

	pasTcpResponse(iFd,psMsgHead,NULL, /* 密钥，暂时不用  */ 3,
					 "compid",   UT_TYPE_LONG,   compid,
					 "Status",   UT_TYPE_STRUCT,  &Status, 1,
					 "Nums",     UT_TYPE_LONG,     Nums2);
}


//7、屏幕日志上传
int Lan_ScreenLog_Up(utShmHead *psShmHead, int iFd,utMsgHead *psMsgHead)
{
	unsigned int   Nums   = 0;
	unsigned int   compid = 0;
	unsigned int   userid = 0;
	char  mac[50];
	unsigned int   groupid = 0;
	unsigned int	groupid2 = 0;
	char  devname[50];
	char  username[50];
	unsigned int   sip  = 0;
	char  procname[100];

	unsigned int stime  = 0;
	char   	file[80];
	char	destPath[512];
	char 	sql[20480];
	char 	sql1[20480];
	char 	sql2[20480];

	char  Status  = 0;
	int   Nums2 = 0;
	long  iReturn = 0;
	FILE   *fp = NULL;
	char dir[512]; //保存目录
	char savefile[512];  //保存的文件??
	//utMsgPrintMsg(psMsgHead);

	char  year[10];
	char  mon[10];
	char  day[10];

	memset(year, 0, sizeof(year));
	memset(mon, 0 , sizeof(mon));		
	memset(day, 0, sizeof(day));

	memset(mac, 0, sizeof(mac));
	memset(devname, 0, sizeof(devname));
	memset(username, 0, sizeof(username));
	memset(procname, 0, sizeof(procname));
	memset(file, 0, sizeof(file));
	memset(destPath, 0, sizeof(destPath));
	memset(sql,  0, sizeof(sql));
	memset(sql1, 0, sizeof(sql1));
	memset(sql2, 0, sizeof(sql2));
	memset(dir,  0, sizeof(dir));
	memset(savefile, 0, sizeof(savefile));

    	iReturn = utMsgGetSomeNVar(psMsgHead,3,
		                        "compid",  UT_TYPE_LONG,  4, &compid,
					"userid",  UT_TYPE_LONG,  4, &userid,
					"Nums",    UT_TYPE_LONG,  4, &Nums
					);

	if (CheckIP(iFd) != 1){
		Status = 1;
		Nums2 = Nums;
		pasTcpResponse(iFd,psMsgHead,NULL, /* 密钥，暂时不用  */ 3,
					 "compid",   UT_TYPE_LONG,   compid,
					 "Status",   UT_TYPE_STRUCT,  &Status, 1,
					 "Nums",     UT_TYPE_LONG,     Nums2);

		recodeLogInfo("屏幕日志：","过滤该信息", "");
		return 0;			
	}


	if( (compid == 0) ){
		Status = 0;
		Nums2 = -3;

		pasTcpResponse(iFd,psMsgHead,NULL, /* 密钥，暂时不用  */ 3,
					 "compid",   UT_TYPE_LONG,   compid,
					 "Status",   UT_TYPE_STRUCT,  &Status, 1,
					 "Nums",     UT_TYPE_LONG,     Nums2);

		recodeLogInfo("屏幕日志：","compid为空", "");
		return -1;
	}

	int   Numbers = 0;
	char  str[12][50];
	char  conver[50];
	memset(str, 0, 12*50);
	memset(conver, 0, sizeof(conver));

	//创建当天日志目录,并将创建的目录存放到dir中，以便后面使用该目录
	createDir(dir,  sizeof(512));

	//查询当前客户端信息
	nwCompInfo *psComp = (nwCompInfo *)utShmHashLook(psShmHead,NC_LNK_COMPUTE,&compid);
	char Mysql[256];
	memset(Mysql, 0, sizeof(Mysql));
	
	sprintf(Mysql,"select groupid from nwgroup where compid=%lu",compid);
	
	pasDbOneRecord(Mysql,0,UT_TYPE_ULONG,sizeof(groupid2),&groupid2);

	for(Numbers = 0; Numbers < Nums; Numbers++)
	{
		snprintf(str[0], 50, "mac%d", Numbers);
		snprintf(str[1], 50, "groupid%d", Numbers);		
		snprintf(str[2], 50, "devname%d", Numbers);
		snprintf(str[3], 50, "username%d", Numbers);
		snprintf(str[4], 50, "sip%d", Numbers);
		snprintf(str[5], 50, "Stime%d", Numbers);
		snprintf(str[6], 50, "file%d", Numbers);
				
		iReturn = utMsgGetSomeNVar(psMsgHead,7,
						str[0],  UT_TYPE_STRING,sizeof(mac)-1, mac,
						str[1],  UT_TYPE_LONG,   4,  &groupid,
						str[2], UT_TYPE_STRING,  sizeof(devname)-1,  devname,
						str[3], UT_TYPE_STRING, sizeof(username)-1,username,
						str[4], UT_TYPE_LONG,   4,  &sip,
						str[5], UT_TYPE_LONG,   4, &stime,
						str[6], UT_TYPE_STRING, sizeof(file)-1,  file
						 );


				char mystring[512];
				memset(mystring, 0, sizeof(mystring));
				snprintf(mystring, sizeof(mystring)-1, " compid=%u, stime=%u", compid, stime);

				if(sip == 0){
					recodeLogInfo(" 收到一条屏幕日志", mystring, "ip = 0");
				}				
				if(stime == 0){
					recodeLogInfo(" 收到一条屏幕日志:", mystring, "Stime == 0");
				}
				if(strlen(mac) <= 0 ){
					recodeLogInfo(" 收到一条屏幕日志:", mystring, "mac== NULL");
				}
				if(strlen(devname) <= 0 ){
					recodeLogInfo(" 收到一条屏幕日志:", mystring, "devname== NULL");
				}
				if( strlen(file) <= 0){
					recodeLogInfo(" 收到一条屏幕日志:", mystring, "file== NULL");
				}
							
				
		//把客户?说鼻笆奔渥换成字符串?如果成功，则 其为屏幕图片存放目录，否则用服务器的当前时间来计算存放目录
		if(timeToString(stime, year,mon,day)== -1){
			time_t now;
			time(&now);
			timeToString(now, year, mon, day);
		}
		snprintf(destPath, sizeof(destPath)-1,  "%s%u/%s%s%s/%u.jpg", SCREENJPG_DIR, compid,year,mon,day, stime);
		recodeLogInfo("屏幕日志：",  destPath, "");


		//保存数据到数据库中
		unsigned long long currentTime = pasGetLongTimeId(); //获取时间

		if(psComp != NULL){
			userid = psComp->userid;
			groupid = psComp->groupid;
		}
		groupid = groupid2;
	
		snprintf(sql, sizeof(sql)-1,  "insert into ncscreenlog_%s%s( compid, userid, groupid,  devname, udisp, mac, sip, stime, file, sid) values(%u, %u, %u, \'%s\', \'%s\', \'%s\', %u, %u, \'%s\', %llu)", year,mon, compid, userid,  groupid, devname, username, mac,sip, stime, destPath,currentTime);
		//printf("sql = %s\n",  sql);

		iReturn = pasDbExecSql(sql,0);
		//printf("iReturn = %d\n", iReturn );
		if(iReturn != 0){
			iReturn = pasDbExecSqlF("create table ncscreenlog_%s%s ( \
    									sid  	    bigint auto_increment  primary key,   \
     									compid    int unsigned,\
									userid    int unsigned default 0,     \
	 								groupid   int unsigned default 0,\
									devname   char(32)  default ' ',      \
									udisp     char(32)  default '',       \
    									mac       char(20)  default '',       \
   			 						sip	      int unsigned,           \
    									stime     int,        \
    									file      char(80)    \
							);", year, mon);
			iReturn = pasDbExecSql(sql,0);
			//printf("iReturn = %u,\n", iReturn);
		}

		if(0 == iReturn){
			Nums2++;
		}								
				
	}//end for()		
	
	if(Nums != Nums2){
		Nums2 = 0;
		char findError1[512];
		memset(findError1, 0, sizeof(findError1));
		snprintf(findError1, sizeof(findError1)-1, "compid=%u, Nums=%d,Nums2=%d", compid, Nums,Nums2);
		recodeLogInfo("屏幕日志：", findError1,"");
	}else{
		Status = 1;
	}

	pasTcpResponse(iFd,psMsgHead,NULL, /* 密钥，暂时不用  */ 3,
					 "compid",   UT_TYPE_LONG,   compid,
					 "Status",   UT_TYPE_STRUCT,  &Status, 1,
					 "Nums",     UT_TYPE_LONG,     Nums2);
	return 0;
}




//8、屏幕JPG图片上传
int Lan_ScreenJPG_Up(utShmHead *psShmHead, int iFd,utMsgHead *psMsgHead)
{
	unsigned int compid = 0;
	unsigned int userid   = 0;
	char         souPath[512];
	char	     destDir[512];
	unsigned int stime = 0;
	char        *buffer =  NULL;
	unsigned int   bufferLength = 0;
	
	int  	iRet = -1;
	int  	Status = 0;	
	int     Nums2 = 0;
	int     iReturn = 0;

	memset(souPath, 0, sizeof(souPath));
	memset(destDir, 0, sizeof(destDir));

//	utMsgPrintMsg(psMsgHead);

	buffer = (char *)malloc(JPG_MAXLEN+1);
	if(!buffer){
		Status = -3;
		stime = 0;
		pasTcpResponse(iFd,psMsgHead,NULL, /* 密钥，暂时不用  */ 3,
					 "compid",   UT_TYPE_LONG,   compid,
					 "Status",   UT_TYPE_STRUCT,  &Status, 1,
					 "Stime",    UT_TYPE_LONG, stime
					);

		recodeLogInfo("接收一条屏幕截图：", "动态开辟空间失败", "" );
		return -1;
	}else{
		memset(buffer, 0 , JPG_MAXLEN+1);
	}

				
	iReturn = utMsgGetSomeNVar(psMsgHead,6,
		                        "compid",  UT_TYPE_LONG,  4, &compid,
					"userid",  UT_TYPE_LONG,  4, &userid,
					"file",    UT_TYPE_STRING,  sizeof(souPath)-1, souPath,
					"currentTime",UT_TYPE_LONG, 4, &stime ,
					"buffer",  UT_TYPE_STRUCT, JPG_MAXLEN, buffer,
					"bufferLength", UT_TYPE_LONG, 4, &bufferLength
					);

	char  year[10];
	char  mon[10];
	char  day[10];

	memset(year, 0, sizeof(year));
	memset(mon, 0, sizeof(mon));
	memset(day, 0, sizeof(day));

	//把客户端当前时间转换成字符串， 如?成??其为屏幕图片存放目录，否则用服务器的当前时间来计算存放目录
	if(timeToString(stime, year,mon,day) == -1){
		time_t now;
		time(&now);
		timeToString(now, year, mon, day);
	}

		
	//创建图片存放目??
	snprintf(destDir, sizeof(destDir)-1,  "%s%u/%s%s%s/",SCREENJPG_DIR, compid,year,mon,day);
	iReturn = mkdir(destDir, S_IRWXU);
	
	if(iReturn != 0){
		snprintf(destDir, sizeof(destDir)-1,  "%s",SCREENJPG_DIR);
		iReturn = mkdir(destDir, S_IRWXU);

		snprintf(destDir, sizeof(destDir)-1,  "%s%u/",SCREENJPG_DIR, compid);
		iReturn = mkdir(destDir, S_IRWXU);

		snprintf(destDir, sizeof(destDir)-1,  "%s%u/%s%s%s/",SCREENJPG_DIR, compid,year,mon,day);
		iReturn = mkdir(destDir, S_IRWXU);
	}
	

	//图片存放路径
	snprintf(destDir, sizeof(destDir)-1,  "%s%u/%s%s%s/%u.jpg",SCREENJPG_DIR, compid,year,mon,day, stime);
	//printf("destDir=%s\n", destDir);

	FILE *fp = fopen(destDir,   "ab");
	if(NULL == fp){
		Status = -1;

	}else{
		int saveLength = fwrite(buffer,1,bufferLength, fp);
		fclose(fp);

		if((bufferLength == 0) || (saveLength < bufferLength)){
			char   receive[1024];
			char   save[1024];
			memset(receive, 0, sizeof(receive)-1);
			memset(save, 0, sizeof(save)-1);
			snprintf(receive, sizeof(receive)-1,  "compid=%u,  接收大小: %d", compid, bufferLength);
			snprintf(save, sizeof(save)-1,  "存储大小: %d", saveLength);
			recodeLogInfo("error：接收到一条屏幕截图：", receive, save);
			Status = 0;
		}else{
			Status = 1;
		        char   receive[1024];
			char   save[1024];
			memset(receive, 0, sizeof(receive)-1);
			memset(save, 0, sizeof(save)-1);
			snprintf(receive, sizeof(receive)-1,  "compid=%u, stime: %u,  filepath=%s", compid,stime, destDir);
			//snprintf(save, sizeof(save)-1,  "存储?笮? %d", saveLength);
			recodeLogInfo(" 接收到一条屏幕截图：", receive, "");
		
		}
		//Status = 1;
	}
	
	//printf("Status = %d\n",   Status);
	pasTcpResponse(iFd,psMsgHead,NULL, /* 密钥，暂时不用  */ 3,
					 "compid",   UT_TYPE_LONG,   compid,
					 "Status",   UT_TYPE_STRUCT,  &Status, 1,
					 "Stime",    UT_TYPE_LONG, stime
					);

	free(buffer);
	return 0;
}

//9、告警日志上传
int Lan_ScreenAlterLog_Up(utShmHead *psShmHead, int iFd,utMsgHead *psMsgHead)
{
	unsigned int   Nums   = 0;
	unsigned int   compid = 0;
	unsigned int   userid = 0;
	char  mac[50];
	unsigned int   groupid = 0;
	unsigned int	groupid2=0;
	char  devname[50];
	char  username[50];
	unsigned int   sip  = 0;
	char  procname[100];

	unsigned int stime  = 0;
	unsigned int screenid = 0;
	int 	 pid = 0;
	char	mesg[256];
	char 	sql[20480];

	char  Status  = 0;
	int   Nums2 = 0;
	long  iReturn = 0;
	FILE   *fp = NULL;
	char dir[512]; //保存目录
	char savefile[512];  //保存的文件名	
	//utMsgPrintMsg(psMsgHead);

	char  year[8];
	char  mon[8];
	char   day[8];

	memset(year, 0, sizeof(year));
	memset(mon, 0, sizeof(mon));
	memset(day, 0, sizeof(day));

	memset(mac, 0, sizeof(mac));
	memset(devname, 0, sizeof(devname));
	memset(username, 0, sizeof(username));
	memset(procname, 0, sizeof(procname));
	memset(mesg, 0, sizeof(mesg));
	memset(sql,  0, sizeof(sql));
	memset(dir,  0, sizeof(dir));
	memset(savefile, 0, sizeof(savefile));

    	iReturn = utMsgGetSomeNVar(psMsgHead,3,
		                        "compid",  UT_TYPE_LONG,  4, &compid,
					"userid",  UT_TYPE_LONG,  4, &userid,
					"Nums",    UT_TYPE_LONG,  4, &Nums
					);

	if (CheckIP(iFd) != 1){
		Status = 1;
		Nums2 = Nums;
		pasTcpResponse(iFd,psMsgHead,NULL, /* 密钥，暂时不用  */ 3,
					 "compid",   UT_TYPE_LONG,   compid,
					 "Status",   UT_TYPE_STRUCT,  &Status, 1,
					 "Nums",     UT_TYPE_LONG,     Nums2);

		recodeLogInfo("告警日志：","过滤该信息", "");
		return 0;			
	}


	if( (compid == 0)){
		Status = -1;
		Nums2 = 0;

		pasTcpResponse(iFd,psMsgHead,NULL, /* 密?浚暂时不? */ 3,
					 "compid",   UT_TYPE_LONG,   compid,
					 "Status",   UT_TYPE_STRUCT,  &Status, 1,
					 "Nums",     UT_TYPE_LONG,     Nums2);

		recodeLogInfo("告警日志：","compid为空", "");
		return -1;
	}


	int   Numbers = 0;
	char  str[12][50];
	char  conver[50];
	memset(str, 0, 12*50);
	memset(conver, 0, sizeof(conver));

	//创建当天日志目录,并将创建的目录存放到dir中，以便后面使用该目录
	createDir(dir,  sizeof(dir));

	//查询当前客户端信息
	nwCompInfo *psComp = (nwCompInfo *)utShmHashLook(psShmHead,NC_LNK_COMPUTE,&compid);
	char Mysql[256];
	memset(Mysql, 0, sizeof(Mysql));
	
	sprintf(Mysql,"select groupid from nwgroup where compid=%lu",compid);
	
	pasDbOneRecord(Mysql,0,UT_TYPE_ULONG,sizeof(groupid2),&groupid2);

	for(Numbers = 0; Numbers < Nums; Numbers++)
	{
		snprintf(str[0], 50, "mac%d", Numbers);
		snprintf(str[1], 50, "groupid%d", Numbers);		
		snprintf(str[2], 50, "devname%d", Numbers);
		snprintf(str[3], 50, "username%d", Numbers);
		snprintf(str[4], 50, "sip%d", Numbers);
		snprintf(str[5], 50, "stime%d", Numbers);
		snprintf(str[6], 50, "screenid%d", Numbers);
		snprintf(str[7], 50, "pid%d", Numbers);
		snprintf(str[8], 50, "mesg%d", Numbers);
				
		iReturn = utMsgGetSomeNVar(psMsgHead,9,
						str[0],  UT_TYPE_STRING,sizeof(mac)-1, mac,
						str[1],  UT_TYPE_LONG,   4,  &groupid,
						str[2], UT_TYPE_STRING,  sizeof(devname)-1,  devname,
						str[3], UT_TYPE_STRING, sizeof(username)-1,username,
						str[4], UT_TYPE_LONG,   4,  &sip,
						str[5], UT_TYPE_LONG,   4, &stime,
						str[6], UT_TYPE_LONG, 4, &screenid,
						str[7],  UT_TYPE_LONG, 4, &pid,
						str[8], UT_TYPE_STRING, sizeof(mesg)-1,  mesg
						 );

				char  mycompid[512];
				memset(mycompid, 0 , sizeof(mycompid));
				snprintf(mycompid, sizeof(mycompid)-1, " compid=%u ,stime=%u",  compid, stime);
				if(sip == 0){
					recodeLogInfo(" 收到一条屏幕告警日志",mycompid, "ip = 0");
				}				
				if(stime == 0){
					recodeLogInfo(" 收到一条屏幕告警日志:",mycompid,  "Stime == 0");
				}
				if(screenid== 0){
					recodeLogInfo(" 收到一条屏幕告警日志:",mycompid,  "screenid== 0");
				}
				if(strlen(mac) <= 0 ){
					recodeLogInfo(" 收??一条屏幕告警日?", mycompid, "mac== NULL");
				}
				if(strlen(devname) <= 0 ){
					recodeLogInfo(" 收到一条屏幕告警???",mycompid,  "devname== NULL");
				}
				if( strlen(mesg) <= 0){
					recodeLogInfo(" 收到一条屏幕告警日志:",mycompid,  "mesg== NULL");
				}


		//保存数据到数据库中
		unsigned long long currentTime = pasGetLongTimeId(); //获取时间

		if(psComp != NULL){
			userid = psComp->userid;
			groupid = psComp->groupid;
		}
		groupid = groupid2;
		

		time_t  now;
		time(&now);
		timeToString(now, year, mon, day);
		
		//printf("current time = %s%s,  compid = %u, groupid = %u, userid=%u\n", year, mon, compid,  groupid,userid);	
	
		snprintf(sql, sizeof(sql)-1,  "insert into nwwarnlog_%s%s( compid, userid, groupid,  devname, udisp, mac, sip, stime, screenid,pid, mesg,  sid) values(%u, %u, %u, \'%s\', \'%s\', \'%s\', %u, %u, %u, %u,  \'%s\', %llu)", 
							year,mon, compid, userid,  groupid, devname, username, mac,sip, stime,screenid,pid,  mesg, currentTime);
		//printf("sql = %s\n",  sql);

		iReturn = pasDbExecSql(sql,0);
		//printf("iReturn = %d\n", iReturn );
		if(iReturn != 0){
			iReturn = pasDbExecSqlF("create table nwwarnlog_%s%s ( \
    									sid  	  bigint auto_increment  primary key,   \
     									compid    int unsigned,\
									userid    int unsigned default 0,     \
	 								groupid   int unsigned default 0,\
									devname   char(32)  default ' ',      \
									udisp     char(32)  default '',       \
    									mac       char(20)  default '',       \
   			 						sip	  int unsigned, \
    									stime     int unsigned,\
    									screenid  int unsigned,\
    									pid       int unsigned,\
    									mesg   	  char(256)\
									);", year, mon);
			iReturn = pasDbExecSql(sql,0);
			//printf("iReturn = %u,\n", iReturn);

		}

		if(0 == iReturn){
			Nums2++;
		}else{
			break;
		}					

	}//end for()		
	
	
	if(Nums > Nums2){
		Nums2 = 0;
		char findError1[512];
		memset(findError1, 0, sizeof(findError1));
		snprintf(findError1, sizeof(findError1)-1, "compid=%d, Status = %d, Nums=%d, Nums2=%d", compid, Status, Nums, Nums2);

		recodeLogInfo("告警日志：", findError1,"");
	}else{
		Status = 1;
	}

	//创建告警屏幕表
	iReturn = pasDbExecSqlF("create table nwwarnscreen_%s%s ( \
    									  	sid       bigint auto_increment  primary key,\
  										warnid    int unsigned,\
    										stime     int,\
    										file      char(80)\
     										);", year, mon);
			


	pasTcpResponse(iFd,psMsgHead,NULL, /* 密钥，暂时不用  */ 3,
					 "compid",   UT_TYPE_LONG,   compid,
					 "Status",   UT_TYPE_STRUCT,  &Status, 1,
					 "Nums",     UT_TYPE_LONG,     Nums2);
	return 0;
}




//10、告警JPG图片上传
int Lan_ScreenAlterJPG_Up(utShmHead *psShmHead, int iFd,utMsgHead *psMsgHead)
{
	unsigned int compid = 0;
	unsigned int userid   = 0;
	unsigned int screenid = 0;
	unsigned int stime = 0;
	char	     destDir[512];
	unsigned long long currentTime = pasGetLongTimeId(); //获取时间
	char         *buffer = NULL; 
	unsigned int   bufferLength = 0;
	
	char	sql[20480];
	int  	iRet = -1;
	int  	Status = 0;	
	int     Nums2 = 0;
	int     iReturn = -1;

	memset(destDir, 0, sizeof(destDir));
	memset(sql, 0, sizeof(sql));


	buffer = (char *)malloc(JPG_MAXLEN+1);
	if(!buffer){
		Status = -3;
		
		pasTcpResponse(iFd,psMsgHead,NULL, /* 密钥，暂时不用  */ 2,
					 "compid",   UT_TYPE_LONG,   compid,
					 "Status",   UT_TYPE_STRUCT,  &Status, 1);
		recodeLogInfo("接收到一条屏幕告警截图：", "动态开辟空间失败", "");
		return -1;
	}else{
		memset(buffer, 0, JPG_MAXLEN+1);
	}


	//utMsgPrintMsg(psMsgHead);			
	iReturn = utMsgGetSomeNVar(psMsgHead,6,
		                        "compid",  UT_TYPE_LONG,  4, &compid,
					"userid",  UT_TYPE_LONG,  4, &userid,
					"screenid",    UT_TYPE_LONG,  4, &screenid,
					"currentTime",UT_TYPE_LONG, 4, &stime,
					"buffer",  UT_TYPE_STRUCT, JPG_MAXLEN, buffer,
					"bufferLength", UT_TYPE_LONG, 4, &bufferLength
					);

	char  year[10];
	char  mon[10];
	char  day[10];

	memset(year, 0, sizeof(year));
	memset(mon, 0, sizeof(mon));
	memset(day, 0, sizeof(day));
	
	//把客户端当前时间转换成字符串， 如果成功，则 其为屏幕?计存放目录，否则用服务器的当前时?来计?娣拍柯?
	if(timeToString(stime, year,mon,day) == -1){
		time_t now;
		time(&now);
		timeToString(now, year, mon, day);
	}


	//创建图片存放目录	
	snprintf(destDir, sizeof(destDir)-1,  "%s%u/%s%s%s/" ,SCREENALTERJPG_DIR, compid, year,mon,day);
	iReturn = mkdir(destDir, S_IRWXU);

	if(iReturn != 0){
		snprintf(destDir, sizeof(destDir)-1,  "%s",SCREENALTERJPG_DIR);
		iReturn = mkdir(destDir, S_IRWXU);

		snprintf(destDir, sizeof(destDir)-1,  "%s%u/",SCREENALTERJPG_DIR, compid);
		iReturn = mkdir(destDir, S_IRWXU);

		snprintf(destDir, sizeof(destDir)-1,  "%s%u/%s%s%s/",SCREENALTERJPG_DIR, compid,year,mon,day);
		iReturn = mkdir(destDir, S_IRWXU);
	}

	//图片存放路径
	snprintf(destDir, sizeof(destDir)-1,  "%s%u/%s%s%s/%u.jpg", SCREENALTERJPG_DIR, compid, year,mon,day, stime);
	//printf("destDir=%s\n", destDir);

	char  myreturn[512];
	memset(myreturn, 0, sizeof(myreturn));
	snprintf(myreturn, sizeof(myreturn)-1, "compid=%u, ireturn = %d, destDir=%s",compid, iReturn, destDir);
	recodeLogInfo("接收到一条屏幕告警截图, 创建路径 ：", myreturn, "");


	FILE *fp = fopen(destDir,   "ab");
	if(NULL == fp){
		char   receive[1024];			
		snprintf(receive, sizeof(receive)-1,  "compid=%u,  该图片存放?肪? %s", compid, destDir);			
		recodeLogInfo("error：接收到一?跗聊桓婢截? 打开路径时失败！ ：", receive, "");

		Status = -1;

	}else{
		int saveLength = fwrite(buffer,1, bufferLength, fp);
		fclose(fp);

		if((bufferLength == 0) || (saveLength != bufferLength)){
			char   receive[1024];
			char   save[1024];
			snprintf(receive, sizeof(receive)-1,  "compid=%u,  接收大小: %d", compid, bufferLength);
			snprintf(save, sizeof(save)-1,  "存储大小: %d", saveLength);
			recodeLogInfo("error：接收到一条告警日志", receive, save);
				
			Status = 0;
		}else{
			
			time_t  now;
			struct tm *time1;
			time(&now);
			time1 = localtime(&now);
		
			//当前年份
			snprintf(year, 5, "%d", time1->tm_year+1900);
			//当前月份
			if( (time1->tm_mon+1 > 0) && (time1->tm_mon+1 <= 9) )
				snprintf(mon, 3, "0%d", time1->tm_mon+1);
			else
				snprintf(mon, 3, "%d", time1->tm_mon+1 );

			snprintf(sql, sizeof(sql)-1,  "insert into nwwarnscreen_%s%s( warnid, stime, file, sid) values(%u, %u, \'%s\', %llu)", year,mon, screenid, stime, destDir,currentTime);
			//printf("sql = %s\n",  sql);

			iReturn = pasDbExecSql(sql,0);
			//printf("iReturn = %d\n", iReturn );
			if(iReturn != 0){
				iReturn = pasDbExecSqlF("create table nwwarnscreen_%s%s ( \
    									  	sid       bigint auto_increment  primary key,\
  										warnid    int unsigned,\
    										stime     int,\
    										file      char(80)\
     										);", year, mon);
				iReturn = pasDbExecSql(sql,0);
				//printf("iReturn = %u,\n", iReturn);
			}

			if(0 == iReturn){
				Status = 1;
			}else{
				Status = -2;	
				recodeLogInfo("接收到一条屏幕告警截图:", sql,  "");
			}
		}							
	}
	
	//printf("Status = %d\n",   Status);
	char   receive[1024]={0};
	snprintf(receive, sizeof(receive)-1,  "compid=%u, stime=%u, status=%d, path=%s", compid, stime, Status, destDir);
	recodeLogInfo(" 接收到一条屏幕告警截图：", receive, "");

	pasTcpResponse(iFd,psMsgHead,NULL, /* 密钥，暂时不用  */ 2,
					 "compid",   UT_TYPE_LONG,   compid,
					 "Status",   UT_TYPE_STRUCT,  &Status, 1);
	return 0;
}

int Lan_ProcessJPG_Up(utShmHead *psShmHead, int iFd,utMsgHead *psMsgHead)
{
	unsigned int compid = 0;
	unsigned int userid   = 0;
	unsigned int screenid = 0;
	unsigned int   stime =0;
	char	     destDir[512];
	unsigned long long currentTime = pasGetLongTimeId(); //获取时间
	char          *buffer = NULL;
	unsigned int   bufferLength = 0;
	
	char	sql[20480];
	int  	iRet = -1;
	int  	Status = 0;	
	int     Nums2 = 0;
	int     iReturn = -1;

	memset(destDir, 0, sizeof(destDir));
	memset(sql, 0, sizeof(sql));


	//utMsgPrintMsg(psMsgHead);
	
	buffer = (char *)malloc(JPG_MAXLEN+1);	
	if(!buffer){
		Status = -3;

		pasTcpResponse(iFd,psMsgHead,NULL, /* 密钥，暂时不用  */ 2,
					 "compid",   UT_TYPE_LONG,   compid,
					 "Status",   UT_TYPE_STRUCT,  &Status, 1);

		recodeLogInfo(" error：接收到一条进程截图:", "动态开辟空间失败", "");
		return -1;
	}else{
		memset(buffer, 0, JPG_MAXLEN+1);
	}

	//提取接收到的信息
	iReturn = utMsgGetSomeNVar(psMsgHead,6,
		                        "compid",  UT_TYPE_LONG,  4, &compid,
					"userid",  UT_TYPE_LONG,  4, &userid,
					"screenid",    UT_TYPE_LONG,  4, &screenid,
					"stime",UT_TYPE_LONG, 4, &stime,
					"buffer",  UT_TYPE_STRUCT, JPG_MAXLEN, buffer,
					"bufferLength", UT_TYPE_LONG, 4, &bufferLength
					);

	char  year[10];
	char  mon[10];
	char  day[10];

	memset(year, 0, sizeof(year));
	memset(mon, 0, sizeof(mon));
	memset(day, 0, sizeof(day));


	//把客户端当前时间转换成字符串， 如果成功，则 其为?聊煌计存放目录，否则用服务器的当前时间来计算存放目?
	if(timeToString(stime, year,mon,day) == -1){
		time_t now;
		time(&now);
		timeToString(now, year, mon, day);
	}


	//创建图片存放目录
	snprintf(destDir, sizeof(destDir)-1,  "%s%u/%s%s%s/",PROCESSJPG_DIR, compid,year,mon,day);
	iReturn = mkdir(destDir, S_IRWXU);

	if(iReturn != 0){
		snprintf(destDir, sizeof(destDir)-1,  "%s",PROCESSJPG_DIR);
		iReturn = mkdir(destDir, S_IRWXU);

		snprintf(destDir, sizeof(destDir)-1,  "%s%u/",PROCESSJPG_DIR, compid);
		iReturn = mkdir(destDir, S_IRWXU);

		snprintf(destDir, sizeof(destDir)-1,  "%s%u/%s%s%s/",PROCESSJPG_DIR, compid,year,mon,day);
		iReturn = mkdir(destDir, S_IRWXU);
	}

	

	//图片存放路径
	snprintf(destDir, sizeof(destDir)-1,  "%s%u/%s%s%s/%u.jpg", PROCESSJPG_DIR, compid,year,mon,day, currentTime);
	//printf("destDir=%s\n", destDir);

	FILE *fp = fopen(destDir,   "ab");
	if(NULL == fp){
		char   receive[1024];			
		snprintf(receive, sizeof(receive)-1,  "compid=%u,  该图片存放路径: %s", compid, destDir);			
		recodeLogInfo(" error：接收到一条进程截图:", receive, "");

		Status = -1;

	}else{
		int saveLength = fwrite(buffer,1,bufferLength,  fp);
		fclose(fp);

		if((bufferLength == 0) || (saveLength < bufferLength)){
			char   receive[1024];
			char   save[1024];
			snprintf(receive, sizeof(receive)-1,  "compid=%u,  接收大小: %d", compid, bufferLength);
			snprintf(save, sizeof(save)-1,  "存储大小: %d", saveLength);
			recodeLogInfo("error：接收到一条进程截图:", receive, save);
				
			Status = 0;
		}else{
			time_t  now;
			struct tm *time1;
			time(&now);
			time1 = localtime(&now);
		
			//当前年份
			snprintf(year, 5, "%d", time1->tm_year+1900);
			//当前月份
			if( (time1->tm_mon+1 > 0) && (time1->tm_mon+1 <= 9) )
				snprintf(mon, 3, "0%d", time1->tm_mon+1);
			else
				snprintf(mon, 3, "%d", time1->tm_mon+1 );

			snprintf(sql, sizeof(sql)-1,  "insert into nwprocscreen_%s%s( procid, stime, file, sid) values(%u, %u, \'%s\', %llu)", year,mon, screenid, stime, destDir,currentTime);
			//printf("sql = %s\n",  sql);

			iReturn = pasDbExecSql(sql,0);
			//printf("iReturn = %d\n", iReturn );
			if(iReturn != 0){
				iReturn = pasDbExecSqlF("create table nwprocscreen_%s%s ( \
    									  	sid       bigint auto_increment  primary key,\
  										procid    int unsigned,\
    										stime     int,\
    										file      char(80)\
     										);", year, mon);
				iReturn = pasDbExecSql(sql,0);
				//printf("iReturn = %u,\n", iReturn);
			}

			if(0 == iReturn){
				Status = 1;
			}else{
				Status = -1;		
			}
		}							
	}
	
	//printf("Status = %d\n",   Status);

	pasTcpResponse(iFd,psMsgHead,NULL, /* 密钥，暂时不用  */ 2,
					 "compid",   UT_TYPE_LONG,   compid,
					 "Status",   UT_TYPE_STRUCT,  &Status, 1);

	free(buffer);
	return 0;
}


int ncInitNwWebFun_Uplog(utShmHead *psShmHead)
{
	pasSetTcpFunName("Lan_FileLog_Up",     Lan_FileLog_Up,    NULL,0,0);
	pasSetTcpFunName("Lan_PorcessLog_Up",  Lan_PorcessLog_Up, NULL,0,0);
	pasSetTcpFunName("Lan_ProcessJPG_Up",  Lan_ProcessJPG_Up, NULL,0,0);
	pasSetTcpFunName("Lan_RmoveLog_Up",    Lan_RmoveLog_Up,   NULL,0,0);
	pasSetTcpFunName("Lan_WebLog_Up",      Lan_WebLog_Up,     NULL,0,0);
	pasSetTcpFunName("Lan_ChatLog_Up",     Lan_ChatLog_Up,    NULL,0,0);
	pasSetTcpFunName("Lan_ScreenLog_Up",   Lan_ScreenLog_Up,     NULL,0,0);
	pasSetTcpFunName("Lan_ScreenJPG_Up",   Lan_ScreenJPG_Up,     NULL,0,0);
	pasSetTcpFunName("Lan_ScreenAlterLog_Up",   Lan_ScreenAlterLog_Up,     NULL,0,0);
	pasSetTcpFunName("Lan_ScreenAlterJPG_Up",   Lan_ScreenAlterJPG_Up,     NULL,0,0);
	pasSetTcpFunName("Lan_EventLog_Up",    Lan_EventLog_Up,   NULL,0,0);

	
	FILE *fp = NULL;
	char   buffer[2048];
	char  *first = NULL;
	char  *second = NULL;
	memset(buffer, 0, sizeof(buffer));
	memset(ConfIP, 0, sizeof(ConfIP));

/*
	fp = fopen( CONF_FILE ,"r");
	if(fp == NULL){
		
	}else{
		fgets(buffer, sizeof(buffer)-1,  fp);

		first = strtok(buffer, " =");
		second = strtok(NULL, "   =");
		
		if(first  && second && (strcmp(first, "analyzerip")) ){
			snprintf(ConfIP, sizeof(ConfIP)-1, "%s", second);
			recodeLogInfo(second, ConfIP,"");

		}
		fclose(fp);
	}
*/
	if(strlen(ConfIP) > 0)
		recodeLogInfo("当前检测客户端", ConfIP,"");
	else
		recodeLogInfo("当前检测所有客户端：","", "");


	

	return 0;
}