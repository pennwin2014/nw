/*********************arTcpApi.h*************************

*

*	Programer:sunyy

*	Date:7/2002

*

******************************************************/

#ifndef ARTCPAPI_H
#define ARTCPAPI_H
#include "arpub.h"
#include "arerr.h"
#include <fcntl.h>
#include <stdarg.h>
#include <sys/select.h>
#include "arTcpErrno.h"
#define SUCCESS	1
#define FAIL	-1
/*****************************************************************

*	名称：TcpSetKeepAlive

*	功能：设置长连接方式，须系统支持

*	调用：在创建SOCKET时，sock为已创建的socket描述符

*		  iCkTime是长连接方式下的检测间隔时间（以秒计）

*	返回值：0--成功；其他--失败

*****************************************************************/

int TcpSetKeepAlive(int sock,int iCkTime);



/*****************************************************************

*	名称：TcpSetLinger

*	功能：设置关闭缓冲时间

*	调用：在创建SOCKET时，sock为已创建的socket描述符

*	返回值：SUCCESS--成功；FAIL--失败

*****************************************************************/

int TcpSetLinger(int sock);



/*****************************************************************

*	名称：add_to_select

*	功能：添加一个套接字到一个等待集合

*	调用：当一个已创建的套接字需等待接受或发送的时候，一般用于服务端

*****************************************************************/

void add_to_select(int sock,fd_set *ready_fdset);



/*****************************************************************

*	名称：TcpOpen

*	功能：创建一个服务端或客户端的SOCKET，若是服务端则处于监听状态，

*		  若是客户端则处于连接状态

*	调用：参数ServerIp==NULL则是服务端，否则是客户端（同时

*		  iListens==0)；iTimeOut是指接受和发送时的延时（以秒计），

*		  bKeepAlive==1则是长连接，bKeepAlive==0则是短连接，

*		  iCkTime是长连接方式下的检测间隔时间（以秒计）

*	返回值：socket描述符--成功；FAIL--失败

*****************************************************************/



int TcpOpen(char *ServerIp, int ServerPort, int iListens, 

			int iTimeOut,int bKeepAlive,int iCkTime,unsigned long lServIp);

/****************************************************************

*	名称：TcpWait

*	功能：确认是否发送或接收已经就绪

*	调用：iSock--已创建（对于服务端）或连结的套接字，iMaxTime--超时时间,

*		  writep--指出是读等待-0，还是写等待-1

*	返回：小于0失败，等于0则超时，大于0则接收或发送就绪

****************************************************************/
int TcpWait(int iSock, int iMaxTime, int writep);

/****************************************************************

*	名称：TcpAccept

*	功能：得到一个用于接收的套接口

*	调用：当一个已创建的监听套接字需接收的时候，用于服务端

*	iSock（输入）--监听的套接字，

*	acClientIP（输出）--客户端的IP地址。

*	返回：小于0失败，大于0则为用于接收的套接字

****************************************************************/
int TcpAccept(int iSock,char *acClientIp,int *piPort);

/*****************************************************************

*	名称：TcpRead

*	功能：读套接字，获得数据，而且是一次全部读完

*	调用：连接成功之后，sBuf是分配的缓冲区,

*	buflen是sBuf的大小,iTmOut是超时时间,piErrno是出错原因码

*	返回值：读取的内容长度--成功；FAIL--失败

*****************************************************************/

long TcpRead(int iSock,int iTmOut, char *sBuf,long lBuflen,int *piErrno);



/*****************************************************************

*	名称：TcpWrite

*	功能：向套接字中写数据

*	调用：sBuf是待写数据缓冲，lLen是待写数据长度,iTmOut是超时时间

*		  piErrno是错误码

*	返回值：成功写入的数据长度--成功；FAIL--失败

*****************************************************************/

long TcpWrite(int iSock, int iTmOut, char *sBuf, long lLen,int *piErrno);



/*****************************************************************

*	名称：TcpClose

*	功能：关闭套接字

*	调用：在所有其他函数之后

*	返回值：OK

*****************************************************************/

int TcpClose(int iSock);
/******************************************************************

*	名称：TcpSend

*	功能：发送内容

*	调用：int iSocket,char *sBuf,int iBuflen

*	返回值：发送的实际长度

******************************************************************/
int TcpSend(int iSocket,char *sBuf,int iBuflen);
/******************************************************************

*	名称：TcpRecv

*	功能：接收内容，但限于一次性连接，即一直收到连接被关闭

*	调用：int iSocket,char *sBuf,int iBuflen

*	返回值：接收的实际长度

******************************************************************/
int TcpRecv(int iSocket,char *sBuf,int iBuflen);

char *getHostName(unsigned long ipaddr);

#endif

/***********************End of arTcpApi.h************************/

