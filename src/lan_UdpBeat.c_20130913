#include <stdio.h>
#include <time.h>
#include <malloc.h>
#include <unistd.h>
#include <pthread.h>
#include "string.h"
#include "utoall.h"
#include "ncdef.h"
#include "nwdef.h"
#include "pasdb.h"

#define LAN_STATUS_CONNECT  10001
#define LAN_STATUS_RUNING   10002



typedef struct _mac_mem{
	struct _mac_mem* prv;
	struct _mac_mem* next;
	char   compid[16];    //计算机ID
    	char   compname[32];  //机器名
	int    userid;        //用户ID
	char   username[16];  //用户名
	char   ip[4];         //IP
	char   mac[18];       //MAC地址
	char   os[32];        //操作系统版本
	char   version[20];   //客户端版本号
    	int    lasttime;      //最后活动时间
   	int    command;       //命令状态
	int    lasttolib;     //最后入库时间,超过配置时间长度，修改入库标记
	char   flags;         //内容修改标志

}MAC_MEM,*pMAC_MEM;

struct index {
	char       compid[16];
	pMAC_MEM   machine;

};

MAC_MEM*	     	m_plist = NULL;                        //链表
unsigned char*   m_index = NULL;                        //索引
pasLHashInfo     sHashInfo; 	                        //key 机器id  value mac_mem结构指针
pthread_mutex_t  mylock = PTHREAD_MUTEX_INITIALIZER;    //互斥锁
int              g_bExit = 0;                           //入库线程是否退出



	
int	Login(utShmHead *psShmHead, utComSockAddr *psSockAddr,utMsgHead *psMsgHead)
{
	int  compid = 0;
	char compname[33];
	char username[17];
	char ip[17];
	char mac[19];
	char os[33];
	char version[21];
	char AuthCode[17];

	int  status = 0;
	int  Userid = 11;
	
   	long iReturn = 0;
   	utMsgPrintMsg(psMsgHead);

	memset(compname, 0 , sizeof(compname));
	memset(username, 0, sizeof(username));
	memset(ip, 0, sizeof(ip));
	memset(mac, 0, sizeof(mac));
	memset(os, 0, sizeof(os));
	memset(version, 0, sizeof(version));
	memset(AuthCode, 0, sizeof(AuthCode));

    	iReturn = utMsgGetSomeNVar(psMsgHead,8, 
							"compid",      UT_TYPE_LONG, 4,  &compid,
							"compname",    UT_TYPE_STRING, 32,  compname,
							"username",    UT_TYPE_STRING, 16,  username,
							"ip",          UT_TYPE_STRING, 16,  ip,
							"mac",         UT_TYPE_STRING, 18,  mac,
							"os",          UT_TYPE_STRING, 32,  os,
							"version",     UT_TYPE_STRING, 20,  version,
							"AuthCode",    UT_TYPE_STRING, 16,  AuthCode							
							);

	//先检查当前机器是否存在索引表中
	if(m_index)
	{
        		struct index * lookindex =(struct index *)pasLHashLook(m_index,compid);
        		if(lookindex)
		{
			//对资源进行加锁
			pthread_mutex_lock(&mylock);

       	       		time_t  now;
			time(&now);
			lookindex->machine->lasttime = now;
			lookindex->machine->lasttolib  =  now;
			lookindex->machine->flags = '0';

			status = lookindex->machine->command;

			//对资源进行解锁
			pthread_mutex_unlock(&mylock);
printf("compid = %s\n", lookindex->machine->compid);
printf("compname = %s\n", lookindex->machine->compname);
printf("username = %s\n", lookindex->machine->username);
printf("ip = %s\n",  lookindex->machine->ip);
printf("lasttime = %d\n",  lookindex->machine->lasttime);
printf("flags=%c\n",  lookindex->machine->flags);

			utComUdpResponse1(psShmHead,psSockAddr,psMsgHead,0,2,
                     			 		 "status",  UT_TYPE_LONG, status, 
							 "Userid",  UT_TYPE_LONG, Userid);
			return 1;
		}	
	}


	//创建新MAC_MEM结点并给其赋值
	pMAC_MEM  node =  (pMAC_MEM)malloc(sizeof(MAC_MEM));

	time_t  now;
	time(&now);
	node->lasttime = now;
	node->lasttolib  =  now;
	node->flags = '0';
	strncpy(node->compid, compid,16);
	strncpy(node->compname, compname,32);
	strncpy(node->username,  username,16);
	strncpy(node->ip,   ip,16);
	strncpy(node->mac, mac,16);
	strncpy(node->os,  os,32);
	strncpy(node->version, version,20);


	//对资源进行加锁
	pthread_mutex_lock(&mylock);

	//把新创建的MAC_MEM结点加入到循环双向链表中
	if(NULL == m_plist)
	{
		m_plist = node;
		node->next = node;
		node->prv   = node;		
	}
	else
	{
		node->next = m_plist;		
		node->prv   = m_plist->prv;
		m_plist->prv  = node;
		m_plist = node;
	}

	//如果索引表为空，则初始化索引m_index
	if(NULL == m_index)
	{
		//初始化  
     		m_index = (unsigned char *)pasLHashInit(30,30,sizeof(struct index),0,16);   
     		if(m_index == NULL) {
        			status = 0;      
   		}
		else
		{
			status = 1;
		}
	}

	//把新创建的MAC_MEM结点加入到索引m_index中
	struct index * addindex = (struct index *)pasLHashLookA(m_index, compid);          
        if(addindex){
    		  addindex->machine = node;
         }	
 
	//对资源进行解锁
	pthread_mutex_unlock(&mylock);

	utComUdpResponse1(psShmHead,psSockAddr,psMsgHead,0,2,
                     			 		"status",  UT_TYPE_LONG, status, 
							 "Userid",  UT_TYPE_LONG, Userid);

	return 1;
}

//当前结点node出链
int     	outLink(pMAC_MEM  node)
{
	int  iRet = 0;
	if(node)
	{
		node->prv->next  = node->next;
		node->next->prv  = node->prv; 
		iRet = 1;
	}
	return iRet;
}

//结点node加入到链头
int	inLink(pMAC_MEM  node)
{	
	int iRet = 0;
	if(node)
	{
		node->next = m_plist;
		node->prv  =  m_plist->prv;
		m_plist = node;	
		iRet = 1;
	}
	return iRet;
}



int	ConnectStatus(utShmHead *psShmHead, utComSockAddr *psSockAddr,utMsgHead *psMsgHead)
{
	int      compid;
	int   Userid = 0
	int   status = 0
	char  AuthCode[17];

	long iReturn = 0
	utMsgPrintMsg(psMsgHead);

	memset(AuthCode, 0, sizeof(AuthCode));

    	iReturn = utMsgGetSomeNVar(psMsgHead,2,
		                        "compid", UT_TYPE_LONG, 4, &compid,
					"Userid", UT_TYPE_LONG,   4, &Userid);
	strcpy(AuthCode,  "110120119");

	
	//根据key查找
	if(m_index)
	{
        		struct index * lookindex =(struct index *)pasLHashLook(m_index,compid);
        		if(lookindex)
		{
			//对资源进行加锁
			pthread_mutex_lock(&mylock);

       	        		time_t  now;
			time(&now);
			lookindex->machine->lasttime = now;
				
			//把当前结点脱链然后再插入到链头
			outLink(lookindex->machine);
			inLink(lookindex->machine);

			status=lookindex->machine->command;

			//对资源进行解锁
			pthread_mutex_unlock(&mylock);
			
		}	
	}

	utComUdpResponse1(psShmHead,psSockAddr,psMsgHead,0,2,
                     			 "status",   UT_TYPE_LONG,   status, 
					 "AuthCode", UT_TYPE_STRING, AuthCode);
	return 1;
}

int  	readTableStruct1(char *filename, char sql[])
{
	int        iRet = 0;
	FILE *file;

	char *first = NULL;
	char  lineData[2000];
	char  sqlCreate[2500];

	memset(lineData, 0, sizeof(lineData) );
	memset(sql,0, sizeof(sql));

	int start = 0;
	
	if(filename == NULL)
		return 0;

	file = fopen(filename,"rb+");
	if(file)
	{
		while(!feof(file))
		{
		
			fgets(lineData,2000, file);

			first = strtok(lineData,"]--");

			if(first   &&  !strcmp(first,"[lan_nwcompute:"))
			{
				start = 1;
				continue;
			}
			else if(first   &&  !strcmp(first,"[/lan_nwcompute"))
			{
				break;
			}

			if(first  &&  start == 1)
			{		
				strcat(sql,first);
			}
		
		}
		fclose(file);
		iRet = 1;	
	}
	else
	{
		printf("open file'UdpBeat.sql ' fail!");
		iRet = 0;
	}
	return iRet;
}

//把头结点入库,并插入到链尾
int 	tolib( )
{
	char   sql[2500];
	long   iReturn = 0;

	if(m_plist)
	{
		//更新入库时间
		time_t  now;
		time(&now);
		m_plist->lasttolib = now;

		//更改入库标记
		m_plist->flags  = '0';

		//把头结点插入到最后
		m_plist = m_plist->next;
			
		//把当前结点数据写入到数据库中
		readTableStruct1("../src/table.sql",sql);
		int  iReturn = pasDbExecSql(sql,0);
		if(iReturn == 0) //创建表成功！
		{
			snprintf(sql,2500,"insert into  \
				lan_nwcompute(  compid,  \
						ip,       \
						compname, \						mac,      \
						os,       \
						lasttime, \
						version,  \
						status    \
					 )               \
				values(%s, %s, %s, %s, %s,%d,%s,%d)",\
				m_plist->compid,         \
				m_plist->ip,            \
				m_plist->compname,      \ 
				m_plist->mac,           \
				m_plist->os,            \
				m_plist->lasttime,      \
				m_plist->version,       \
				m_plist->command        \
				);
			iReturn = pasDbExecSql(sql,0);
		}
		else //创建表失败
		{
			printf("创建表失败！");	
		}	


printf("入库！！！................\n");
printf("compid = %s\n", m_plist->compid);
printf("compname = %s\n", m_plist->compname);
printf("username = %s\n", m_plist->username);
printf("ip = %s\n", m_plist->ip);
printf("lasttime = %d\n",  m_plist->lasttime);
printf("flags=%c\n",  m_plist->flags);
	}

	return 1;				

}

void *	UpdateToLib(void)
{	
	while(!g_bExit && m_index != NULL)
	{	
		int g_nTotalLows =  pasLHashRecord(m_index);  //索引表中结点总数
		int count=0;
		while(m_plist)
		{			
			//当前头结点入库
			if('1' == m_plist->flags)
			{
				//对资源进行加锁
				pthread_mutex_lock(&mylock);

				//当前头结点入库
				tolib();

				//对资源进行解锁
				pthread_mutex_unlock(&mylock);
				
			}
			else //如果当前结点标记为空，则结束本次遍历
			{	
				break;
			}
				
			
			count++;
			if(count>(g_nTotalLows - 1))break;
			
		}
		sleep(60);
	}
	
}
//心跳机制----连接
int Lan_Status_Connect(utShmHead *psShmHead, utComSockAddr *psSockAddr,utMsgHead *psMsgHead)
{
	Login(psShmHead, psSockAddr,psMsgHead);
}

//心跳机制---运行
int Lan_Status_Runing(utShmHead *psShmHead, utComSockAddr *psSockAddr,utMsgHead *psMsgHead)
{
	ConnectStatus(psShmHead, psSockAddr,psMsgHead);
}


int ncInitNwWebFun_UdpBeat(utShmHead *psShmHead)
{

 //   	pthread_t id1;

    	/*创建线程*/

//    	int ret = pthread_create(&id1, NULL, (void *)UpdateToLib, NULL);

	//初始化互斥锁
//	ret = pthread_mutex_init(&mylock,NULL);

	utComSetUdpFun(LAN_STATUS_CONNECT,Lan_Status_Connect);
	utComSetUdpFun(LAN_STATUS_RUNING, Lan_Status_Runing);

	printf("UdpBeat   init   ok!\n\n");
}
